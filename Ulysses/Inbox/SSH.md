
**远程加密登录**
电脑之间加密.就算数据在中间被截获 密码也不会泄露.

- `ssh user@host`             默认登录方法(22 端口)
	- `ssh -p 2222 user@host`     服务器改过端口用这个


**SSH 过程**
1. 服务器 收到用户请求: 把自己的公钥发给用户.
	2. 用户用这个公钥.把登录密码加密后发回.
		3. 服务器用私钥 解密登录密码.
			4. 如果密码正确 就同意登录


**中间人攻击:**
1. 中间人*截获登录请求!!!
	2. 中间人冒充服务器: 给用户发假的公钥
		> SSh 的公钥是没有证书中心 (CA)认证的  
		> 不像 Https 有 CA 认证的.
	3. 然后用户就把 中间人当成服务器. 
	4. 把登录密码用中间人的公钥加密发给中间人.
	5. 中间人用私钥解开密码.
	6. 中间人用 这个密码 登录真正的服务器



*密码登录:*

第一次登录服务器 会弹出提示:
无法确认 服务器的真实性.只知道服务器的 公钥 要继续么
服务器的公钥 被接受之后. 
会保存在 本地的 `/.ssh/known_shosts`  文件中.
下次连就不会弹出警告了.


**公钥登录**
> 要求必须提供用户的公钥.  
> 没有现成的话 可以用 ssh-keygen 生成一个.

密码登录每次都得输密码. 这个密码还不能太简单不然服务器会被黑.
公钥登录,可以免去输入密码了.


*公钥登录原理*
1. 用户把自己的公钥 存储到服务器上.
	2. 登录的时候: 服务器向用户发送一段随机字符串.
		3. 用户用自己的私钥加密随机字符串 发回给服务器.
			4. 服务器用事先存在服务器上的用户的公钥进行解密.
				5. 解密成功:允许登录.不再要求密码.



	*公钥 生成& 使用*
	1. `ssh-keygen`
		> 会在 `~/.ssh/` 目录下生成两个文件
		> - `id_rsa.pub`  → 公钥
		> - `id_rsa`      → 私钥


		2. `ssh-copy-id user@host`
			> 把公钥传送到服务器上

3. 重启服务器的 ssh 服务.


	`authorized_keys`

	远程主机将用户的公钥，保存在登录后的用户主目录的`$HOME/.ssh/authorized_keys`文件中。
	*公钥就是一段字符串*
	只要把它追加在`authorized_keys`文件的末尾就行了。


	*公钥保存过程*

	`$ ssh user@host 'mkdir -p .ssh && cat >> .ssh/authorized\_keys' < \~/.ssh/id\_rsa.pub`

	- `ssh user@host`   → 登录服务器

		- `mkdir -p .ssh`   → 如果用户主目录 没有 .ssh 这个目录就创建一个.
			 
		- `cat >> .ssh/authorized_keys' < ~/.ssh/id_rsa.pub`
			把本地的公钥文件 (ras.pub)
			重定向 追加到 服务器上 authorized 文件的尾行.



*远端操作*

在本地 直操作 服务器.
只要能通过 ssh 完成的 都能远程操作.

如: 
1. 把 home/src 下面所有文件复制到服务器 home/src
	`cd && tar czv srv | ssh user@host 'tar xz'`

	2. 查看远程主机是否运行 httpd
		``ssh user@root ‘ps ax | grep `[h]ttpd\```



*绑定本地端口:*

SSH 可以传送数据. 那么久可以让本地那些不安全的网络连接 全部走 ssh 提高安全.  比如公共 wifi.

*让 8080 端口数据 都先通过 ssh 再访问别的地方*

`ssh -D 8080 user@host`
- ssh 会建立一个 socket 去监听本地 8080端口.
	- 一旦有数据传到那个端口 就转移到 ssh 上,
		- 如果原来 8080 是不加密的 现在就变成加密的了.





## 本地端口转发 ( SSH -L )/ SSH 隧道
> 使得 host1 和 host3 之间形成一条传输数据的秘密隧道.

本地电脑 就像个中转站.数据中转用

*Example:*
- host1 家里主机         (有外网)
	- host2 公司数据库服务器 (无外网!)
	- host3 公司办公电脑     (有内外网 )
		> 也就是可以同时连通host1 & host2

*host1  要连到 host2  就必须经过 host3 中转!!
> 所以这里的本地端口转发 就是 host3 

1. host1 执行:  
	`ssh -L 2121:host2:21 host3`
	*L 参数* 接受 三个值 (用 : 隔开)
	本地端口  / 目标主机 / 目标主机端口.

	ssh 绑定本地的2121端口.
	指向 host3 
	吧 host3 的所有数据 转发到 host2的 21端口.

	→  只要连上了 host 的21端口 就连上了 host2 的21端口.




## 远程端口转发 / SSH -R

绑定 远程端口的转发.
本地端口转发 
需要有一台 额外的电脑!! 
而且这个电脑还不能是内网电脑.


还是上面的例子:

*host1 家里的电脑  在公网*
*host2 公司服务器  在内网 * 只有内网!!!  (如内部数据库) 
*host3 公司办公PC  在内网*  同时有内外网!!!
> 办公电脑都这样的.怎么可能不能上网... 

现在: 

1 2 之间无法直接连通.  必须借助 3 转发.
host1 不可连 host3 因为 host3 无公网 ip
host3 可以连 host1 因为host1 有公网 ip
host3 还能连 hsot2 因为都在内网


现在实现要  host1  连 host2
host1 是远程主机.
host2 是目标主机.

 1. host3 上执行:    `ssh -R 2121:host2:21 host1`
	R参数 三个值:
	- 远程主机端口  : host1的端口
		- 目标主机        host2
			- 目标主机端口    host2 的端口

		让 host1 监听 host1 自己的2121端口.
		所有数据 经过 host3 转发到 host2 的21.



	2. 绑定之后 在 hsot1 就可以连接 host2了
		host1 :  ftp localhost:2121

	> 远程端口转发前提: host1 有 sshd






	  
	 



























