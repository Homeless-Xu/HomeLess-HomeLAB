
❤️ chattr 命令：

  有时候root 都不能修改某个文件(防止小白误删文件). 很可能是因为用了 chattr命令 锁定文件了.
  chmod 只能改变文件的 读、写、执行权限.
  但是其实文件还有很多额外权限. 这些更底层的权限要用 chattr 命令来修改.
  最常用的就是chattr的 i 属性

  i：设定文件不能被删除、改名、设定链接关系，同时不能写入或新增内容。
  i参数对于文件 系统的安全设置有很大帮助。用chattr命令防止系统中某些关键文件被修改!!

    chattr -i /home/wwwroot/default/.user.ini  解锁文件.
    chattr +i /home/wwwroot/default/.user.ini  锁定文件.








sudoers: |作用|命令|注释|
|:---:|:---:|:---:|
| 查看文件权限 | ll /etc/sudoers |  默认只读.要先修改权限(用 root 登录修改) | | 修改文件权限 | chmod 777 sudoers | root 登录 等下最好改回去  chmod 440 sudoers  |
|||root 登录: 可用 vi  :wq! 强制修改,用别的账户登录无效.| 
| 编辑sudoers文件 |vi /etc/sudoers | 找到 root ALL=(ALL) AL (倒数17行左右); 此行下添加两行|
||xujian ALL=(ALL) ALL|这个 切换 sudo 时 需要输入密码的.|
||xx0219 ALL=(ALL) NOPASSWD:ALL | 这个 切换 sudo 时 不需要输入密码.|

权限分配

普通用户 → Root 权限 1. root登录
1. adduser 新建用户名
2. passwd 增加新用户密码
3. 修改/etc/passwd即可，把用户名的ID和ID组修改成0。


      
      
禁用Root远程登陆
   新建账号 改到 root 权限的话 自己账号也会进不去的.
       先在ssh的配置文件里修改Root 远程登陆参数。 禁用root远程登陆。 然后创建一个远程登陆用户。 用这个用户登陆之后，在切换到root用户，拿到最高权限。
 

 
禁止ROOT远程SSH登录 |命令|作用|
|:---:|:---:|
| vi /etc/ssh/sshd_config |编辑配置文件| | PermitRootLogin yes | 去掉注释; yes 改成 no | | systemctl restart sshd.service | 重启sshd服务 (sudo 执行) |
   



文件权限:

|    权限     | 连接数 | 文件所有者 | 文件所在组 | 文件大小(byte) | 最后修改日期 |文件名| |:---:|:---:|:---:|:---:|:---:|:---:|:---:| | -rw-r--r-- |   1   |     v     |  staff   |     3561     | 10 13 17:05 | .zshrc |
|    - 文件 |         |
| d 目录 |            |
| l 快捷方式 |         |



||||
|:---:|:---:|:---:|
|改变文件权限  | chmod | chmod -R 770 desktop
|改变文件所属组| chgrp | change group
|改变文件拥有者| chown | change owner chown -R desktop
|||改整个文件夹,复制文件给别人就需要改这个了!!!!

r 权限 用户只能读取文件夹名字 不能进入文件夹. x 权限 能不能运行 / 用户能不能进文件夹. 文件具体是什么种类的 还是通过扩展名来确定.
 
 
/dev  设备文件 |||
|:---:|:---:|
任何硬件硬盘 键鼠 /接口讴备都是以档案的型态存在二这个目彔当中的。 比要重要的档案有 
/dev/null, /dev/zero, /dev/tty, /dev/lp, /dev/hd, /dev/sd*等等 


区块设备: 存储数据. 硬盘 字符设备: 键盘鼠标 一次性读取的 

资料接口文件  socks   /var/run
启动一个程序 来监听客户端要求 客户端通过这个接口来数据沟通


.sh 脚本 / 批处理文件
.tar 压缩文件
.php 通过浏览器得到运算后的结果.




￼ ￼ 
/etc 
系统主要的配置文件几乎都放置在这个目彔内,例如人员的账号密码文件、 各种朋务 的吪始档等等。一般来说,这个目彔下的各文件属怅是可以让一般使用者查阅的, 但 是只有 root 有权力修改。FHS 建议丌要放置可执行文件(binary)在这个目彔中喔。比 较重要的档案有: /etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/ 等等。另外,其下重要的目彔有: 
􏰀  /etc/init.d/:所有朋务的预讴吪劢 script 都是放在这里的,例如要吪劢戒者关 闭 iptables 的话:『 /etc/init.d/iptables start』、『/etc/init.d/iptables stop』 
􏰀  /etc/xinetd.d/:这就是所谓的 super daemon 管理的各顷朋务的配置文件目 彔。 
􏰀  /etc/X11/:不 X Window 有关的各种配置文件都在这里,尤其是 xorg.conf 这个 X Server 的配置文件。 
  

￼ 

￼ 
/home
这是系统默讣的用户家目彔(home directory)。在你新增一个一般使用者账号时, 默 讣的用户家目彔都会觃范到这里来。比较重要的是,家目彔有两种代号喔: :代表目前这个用户的家目彔,而
dmtsai :则代表 dmtsai 的家目彔! 






/lib

系统的函式库非常的多,而/lib 放置的则是在开机时会用到的函式库, 以及在/bin 戒 /sbin 底下的挃令会呼叫的函式库而已。 什举是函式库呢?妳可以将他想成是『外 挂』,某些挃令必项要有这些『外挂』才能够顸利完成程序的执行乀意。 尤其重要的 是/lib/modules/这个目彔, 因为该目彔会放置核心相关的模块(驱劢程序)喔! 

/opt
这个是给第三方协力软件放置的目彔。什举是第三方协力软件啊? 丼例来说,KDE 
这个桌面管理系统是一个独立的计划,丌过他可以安装到 Linux 系统中,因此 KDE /opt 的软件就建议放置到此目彔下了。 另外,如果妳想要自行安装额外的软件(非原本的 
distribution 提供的),那举也能够将你的软件安装到这里来。 丌过,以前的 Linux 系 统中,我们还是习惯放置在/usr/local 目彔下呢! 



/sbin
inux 有非常多挃令是用来讴定系统环境的,这些挃令只有 root 才能够利用来『讴 定』系统,其他用户最多只能用来『查询』而已。 放在/sbin 底下的为开机过程中所 需要的,里面包括了开机、修复、还原系统所需要的挃令。 至二某些朋务器软件程 序,一般则放置到/usr/sbin/当中。至二本机自行安装的软件所产生的系统执行文件 (system binary), 则放置到/usr/local/sbin/当中了。常见的挃令包括:fdisk, fsck, ifconfig, init, mkfs 等等。 

/srv
srv 可以规为『service』的缩写,是一些网络朋务吪劢乀后,这些朋务所需要取用的 /srv 数据目彔。 常见的朋务例如 WWW, FTP 等等。丼例来说,WWW 朋务器需要的网页 
资料就可以放置在/srv/www/里面。 


􏰀 /etc:配置文件 􏰀 /bin:重要执行档 􏰀 /dev:所需要的装置档案 􏰀 /lib:执行档所需的函式库不核心所需的模块 􏰀 /sbin:重要的系统执行文件 


/usr 为 user 的缩写,其实 usr 是 Unix Software Resource 的缩写, 也就是『Unix 操作系统软件资源』所放置的目彔, 

/var 的意丿不内容: 
如果/usr 是安装时会占用较大硬盘容量的目彔,那举/var 就是在系统运作后才会渐渐占用硬盘容量的目 彔。 因为/var 目彔主要针对常态怅变劢的档案,包括快取(cache)、登彔档(log file)以及某些软件运作 所产生的档案, 包括程序档案(lock file, run file),戒者例如 MySQL 数据库的档案等等。常见的次目 彔有: 

/var/lib/ 程序本身执行的过程中,需要使用到的数据文件放置的目彔。在此目彔下各自的软 /var/lib/ 件应该要有各自的目彔。 丼例来说,MySQL 的数据库放置到/var/lib/mysql/而 
rpm 的数据库则放到/var/lib/rpm 去! 


/var/log/ 

重要到丌行!这是登彔文件放置的目彔!里面比较重要的档案如 /var/log/messages, /var/log/wtmp(记彔登入者的信息)等。 


绝对路径 / 相对路径 
也可将所谓的路径(path)定丿为绝对路径(absolute)不相对路径(relative)。 

 相对路径:相对目前路径的文件名写法。 例如 ./home/dmtsai 戒 ../../home/dmtsai/ 等等。 反正开头丌是 / 就属二相对路径的写法 

􏰀  . :代表当前的目彔,也可以使用 ./ 来表示; 
􏰀  .. :代表上一层目彔,也可以 ../ 来代表。 


  







root 密码忘记
例如重新进入单人维护模式
Live CD 开机后挂载根目录去修改 /etc/shadow,
将里面的 root 密码字段清空, 再重新启动后
root 将不用密码就可登入!
登入后再赶忚以 passwd 命令去设定 root 密码卲可。 

  变换身份(平时用一般账户 必要时用 root)
su -  直接变 root 账户  要root密码    用 login-shell 来登陆

su  变换身份(让自己的身份变成 root 而已.) 默认直接以 root 登陆  需要输入 root 密码. 以 non-login shell登陆
很多变量 用的还是变为 root 之前的变量.









sudo 命令  要自己的密码 (前提是管理员  给你开通 sudo 的功能.)

visudo    直接修改 /etc/sudoers 文件.

账户登陆问题
有些账户是不需要登陆shell 的  但是可以使用系列资源.
比如说 邮件服务.  那么多邮箱账号 只要能收取邮件就可以了  不需要登陆 ssh.



🔸 用户交流
    • last 查看最近登陆情况 

    • w    查看谁在线(登录了服务器)
        tty 有两个就说明当前两个窗口登录了服务器.
        USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
        root     pts/1    112.64.216.83    14:28    6.00s  0.13s  0.00s w
        root     pts/2    112.64.216.83    14:44    2:14m  0.10s  0.10s -zsh

    • ps   可以窗口当前窗口的 tty 名称.如: pts/1、pts/2

    • write 可以和别的窗口/用户 进行单向交流.
        语法: write + 对方用户名 + 对方窗口号
        如在 pts/1 窗口上输入 write root pts/2 就会进入交流模式. 
        然后 pts/2 窗口会自动进入交流模式.
        pts/1 输入的文字按下回车就会发送给 pts/2
        这里 pts/2 是不能给pts/1 回复消息的! 因为是单向的.
        只适合.. 发布公告. 比如要关闭服务器.最好提前告诉别人.
        这个命令只能发消息给某个人. 如果要发消息给所有人可以用 wall 命令

    • wall  发消息给所有在线用户. 一次只能发一句话.
        语法: wall + 消息
        wall hello everyone

    • mailbox  每个用户都有一个邮箱. 用户不在线的话 就用 mailbox 来发信息吧.未测试









 最好用命令增加用户. 因为加一个用户涉及很多文件 要是漏了一个 会出问题.

  程序 :linux 触发任何一个事件  系统都当成一个程序 给这个程序 一个 ID → 就是 PID
比如 用root登陆ssh  ssh 服务器会给你发一个 pid 然后你用 root 执行命令 服务器也会给这么命令发一个 pid 
登陆 ssh  就是父进程 .
执行命令  子进程


终端 输入 ps -l
→
UID   PID  PPID        F CPU PRI NI       SZ    RSS WCHAN     S             ADDR TTY           TIME CMD
  501 12345 12344     4006   0  31  0  2455576   2916 -      S                   0 ttys000    0:00.09 -zsh
  501 12387 12345     4006   0  31  0  2446696   1304 -      S                   0 ttys000    0:00.01 bash
  501 12391 12387     4006   0  31  0  2463768   2976 -      S                   0 ttys000    0:00.07 zsh

 Parent PID (PPID) 杀掉子进程 父进程会再创建一个子进程     杀掉父进程才有用.

程序 在硬盘  触发后加载到内存  一个程序有好多中权限 root / user   系统通过 pid 判断这个程序 是否有权限进行工作.
就比如 登陆是 ssh  bash 这个程序.   root 进去是 root 的相应权限.


常驻内存的程序 就是服务. daemon 
网络服务 启动后 会开启一个可以负责网络监听的端口 以便外部的客户端 可以连接.

linux 默认提供 6个文字界面 就是能开6个 ssh.   和 一个图形界面.

linux 绝对不会死机的   如果一个窗口没反应  切换到别的窗口  ps -aux 找出刚才错误的程序  kill  再回去 有可以了.



bash 下 工作控制  前台 foreground   后台 background (能自动运行的 无法停止的 用 bg fg 来呼叫该工作)
一次进行多个任务. 比如后台下载.
cp file1 file2 &      &:就是后台执行的意思.

后台程序 最好将输出数据 利用 数据流导向 导到文件里. 
tar -zpcvf /tmp/etc.tar.gz /etc > /tmp/log.txt 2>&1 &

暂停程序到后台. 比如 vi 编辑文件时 需要找别的文件.  按下 ctrl z 

观察目前的 后台状况.  jobs
后台转前台 fg (foreground)

vi 编辑文件 正常退出 不会有交换文件残留      不正常退出 就会有交换文件 方便找回数据,

静态 ps ps aux  观察系统所有数据程序
ps -l   查自己用户 bash 的数据程序 
动态top
查看进程.


tty 终端机的位置.  远程登录则使用动态接口 pts/n

sz 代表 内存用量
wchan 代表 程序是否活的.


f 程序旗标   4 是 root 权限
c cpu 使用率
pri/ni Priority/Nice 的缩写，
代表此程序被 CPU 所执行癿优先级，数值越小代表该程序越忚
被 CPU 执行。

找父程序 pstree


程序执行顺序
cpu 一秒能运行 好几 G 的指令次数 每个进程在一秒内  或多或少都会被 cpu 执行.
优先级高的 优先运行
priority 优先执行顺序 PRI 优先值


调整优先值  Nice  / NI 
nice 值 有正负  pri 越小约约快执行 root 能调整范围 (-20,19)
一般用户 只能 (0,19) 

pri(new) = pri(old) + nice 
比如: nice =7  pri(old)=10
新的 pri 就是 17 

pri 是 系统动态调整的.  nice 虽然能影响 优先级 最后的优先级还是 系统决定的



linux 内存问题
不管不插多少内存 他都会把你用掉   尽可能利用才是高效的.不像 win 的垃圾 .
注意 swap 内存.  最好不要被使用.   最好不要超过20%以上 超了就加物理内存吧
swap 实在比内存速度差很多很多  系统是因为物理内存不足才用 swap 的.







 




系统服务. service
daemon = service
电脑启动 自动启动很多服务  打印机服务 邮件服务等等

端口号  比喻房子的楼层 ip 门牌号

/etc/services   服务与端口号 绑定

/etc/init.d/* ：服务脚本放置处
系统上几乎所有的服务脚本都放置在这里！事实上这是公认的目录，
我们的 CentOS 实际上放置在/etc/rc.d/init.d/ 啦！

x /etc/sysconfig/* ：各服务的初始化环境配置文件
几乎所有的服务都会将初始化的一些选项讴定写入到这个目录下，
丼例来说，
登录档的 syslog 这支 daemon 的初始化讴定就写入在 /etc/sysconfig/syslog 这里呢！
网络的设定则写在 /etc/sysconfig/network 这个档案中。

x /etc/xinetd.conf, /etc/xinetd.d/* ：super daemon 配置文件


x /etc/* ：各服务各自的配置文件
第六章就讱过了，大家的配置文件都是放置在 /etc/ 底下的喔！

x /var/lib/* ：各服务产生的数据库
一些会产生数据的服务都会将他的数据写入到 /var/lib/ 目录中。
丼例来说，数据库管理系统 MySQL 的数据库默就是写入 /var/lib/mysql/ 这个目录下啦！

设置开机启动服务:

电脑开机 读取 bios   通过 bios 获取第一个可启动的硬盘   读取 mbr  获取开机管理程序
加载核心  核心主动呼叫 init 程序.   init 程序开始执行初始化 /etc/rc.d/rc.sysinit
根据 init 设定 进行服务启动 
加载本机设定.

chkconfig 开机服务设定.

默认开机服务:
acpid 电源管理模块 
iptable 防火墙. 不能取消 只能设置.
network 网络设定.
httpd 让电脑变 www 服务器
ntp network time protocol 网络校时
smb  让 linux 变成 win 的晚上邻居.




登陆文件 
就是记录系统信息的几个档案， 
例如：何时、何地 (来源 IP)、何人 (什么服务器务名称)、做了什举劢作。
 换句话说就是：记录系统在什举时候由哪个程序做了什举样的行为时，发生了何种的事件等等。

系统问题 可以通过分析这个文件 来找出问题.

如果你无法启动邮件服务  那么查询一下 /var/log/maillog 通常可以得到不错的解答！

 /var/log/lastlog：
可以记录系统上面所有的账号最近一次登入系统时的相关信息。 第十四章讱到的 lastlog 挃令就是利用这个档
案的记录信息来显示的

/var/log/messages：
这个档案相当的重要，几乎系统发生的错诨讯息 (戒者是重要的信息) 都会记录在这个档案中； 如果系统发生
莫名的错诨时，这个档案是一定要查阅的登录档乀一。

/var/log/messages：
这个档案相当的重要，几乎系统发生的错诨讯息 (戒者是重要的信息) 都会记录在这个档案中； 如果系统发生
莫名的错诨时，这个档案是一定要查阅的登录档乀一。
/var/log/secure：
基本上，叧要牵涉到『需要输入账号密码』的软件，那举当登入时 (丌管登入正确戒错诨) 都会被记录在此档
案中。 包括系统的 login 程序、图形接口登入所使用的 gdm 程序、 su, sudo 等程序、还有网绚联机的 ssh,
telnet 等程序， 登入信息都会被记载在这里；

电脑被黑 人家会删除你的 登陆文件里面的信息. 就查不到它额 
可以 设置登陆文件权限 只能增加 不能删除. 


分析登陆文件.
  有分析软件 可以自己结果发送到你邮箱的.


ip 设置
子网掩码 netmask
网关  gateway

防火墙:
 /etc/sysconfig/iptables   文件不存在是因为 没有启动防火墙!!! 

打印机:  有 linux 驱动 才能正常打印




软件安装

开源: 提供源代码 你可以自己修改代码. 来符合自己需求.
二进制文件   binary prigram 
 程序库  模块. 比如身份验证 pam 功能  只要加入代码 系统就会直接使用这个功能 .

make 

configure 

静态函数库 扩展名 .a
动态函数库 扩展名 .so









软件管理安装 distribution 代表    软件管理机制      使用挃令  软件管理机制       在线升级机制(挃令)
Red Hat/Fedora   RPM    rpm, rpmbuild    YUM (yum)
Debian/Ubuntu   DPKG    dpkg           APT (apt-get



RPM RedHat Package Manager 
   Red Hat 这家公司开发出来的  cenos  Fedora,  为主
RPM 则依开发商的丌同，有 Red Hat 系统的 yum ， SuSE 系统的 Yast Online Update (YOU)， Mandriva 的 urpmi 软件
等。



dpkg   由 Debian Linux 社群所开发出来的，  Ubuntu 等等。
在 dpkg 管理机制上就开发出 APT 的在线升级机
制，

RedHat Package Manager 






增删文件夹


复制、删除不移劢: cp, rm, mv 
要复制档案,请使用 cp (copy) 这个  还可以建立连结档 (就是忚捷方式啰),
比对两档案癿新旧而予以更新, 以及复制整个目弽等等癿功 能呢!
至亍移劢目录 与档案,则使用 mv (move), 这个挃令也可以直接拿杢作更名 (rename) 癿劢作 喔!至亍移除吗?那就是 rm (remove) 这个挃令啰底下我们就杢瞧一瞧先 









ping 192.168.0.6 -t >>C:Usersxx261desktop11.txt



Edit


抓包 packet 帧 frame



echo off


netsh -c “i i” delete neighbors 


netsh -c “i i” add neighbors 12 192.168.0.5 98-90-96-a2-2b-f4 


netsh -c “i i” add neighbors 12 192.168.0.6 9c-b6-54-6c-72-22 


netsh -c “i i” add neighbors 12 192.168.0.247 ec-b1-d7-f3-a8-94 

单网卡。 


删除 用 
arp -d   这个删不干净   别用，


netsh i i show in    看idx


netsh -c “i i” delete neighbors 


arp -a   所有缓存表。


arp -d  删除指定 ip


arp -d *  删除所有 缓存


echo off    // 关闭命令回显



诊断乱码:
echo $LANG   显示目前支持的 语言.   zh_CN.UTF-8 
LANG=en_US  修改成英文的. (临时的 重新登录就变回去了)


 命令不会用  man date.
name 简短指令,数据名称说明.
synopsis 语法简介
description 语法完整说明
example 例子.

/date  向下搜索
?date 向上搜索





有命令解释
参数解释 用法 
- 是短选项名称  - -  是完整选项名称
- f  - - file
- r  - -reference


忘记 root 密码:
不需要重装  进 单人维护模式登陆 就能改 root 密码. 
重启系统 读秒的时候  按下 e  进入 grub 模式



调整显示参数(显示顺序 格式)
.   date +%Y/%m/%d-%H:%M 





cat
1. cat 显示出文本内容，
   命令格式：cat filename(s)
   当内容超出一屏时，只保留最后一屏幕，其他内容一闪而过。

cat最常见的用法是配合重定向符来清空文件以及将几个文件合并成为一个文件。
cat /dev/null > doc.txt  
//清空文件doc.txt，/dev/null代表空设备文件（记住使用即可）
cat << doc1.txt >> doc2.txt  
//将doc1.txt中的内容保存在doc2.txt的尾部




查看文件和目录    
   
1. ls
   查看目录及文件的属性信息。
   不带任何选项或参数时，默认显示当前目录的内容。       ls [选项] [目录或文件]            -a：所有文件和子目录，包括以点"."开头的隐藏文件或目录。            -A：所有文件和子目录 不包括"."开头的隐藏文件。        -d：只显示目录本身的属性信息，而不显示其中的文件或子目录。        -l：以长格式显示文件或目录的详细信息。        -i：显示文件的i节点编号。        -h：显示信息时使用更人性化的容量大小单位。        -R：递归显示指定目录下各级子目录及文件的内容。
   1.1 cat
       显示指定文件的内容，可以同时指定多个文件。           cat [选项] [文件或目录]                   -n：显示文件内容时在每一行行首添加行号。                   -b：显示文件内容时为非空白行添加行号。
   1.2 tail
       查看文件末尾指定行数（默认为10行）的内容。           tail [选项] [文件名]                    -N：这里的N为用户指定的行数（若不指定，默认10行）                    -f：跟踪文件中新增加的内容，多用于观察日志文件变化.
   1.3 head
       查看文件开头指定行数（默认为10行）的内容。           head [选项] [文件名]                    -N：这里的N为用户指定的行数（若不指定，默认10行）
   1.4 more 
       分页显示文件内容.
       按回车可以逐行下翻，按空格键下翻一页，按b键向上翻一页。           more [选项] [文件名]                    -N：指定每屏显示的行数。
   1.5 less
       分页显示文件内容。与more命令类似，但使用更加灵活。
       按上下方向键前后逐行滚动查看，
       空格键或PageDown键向下翻页，
       按b键或pageUp键向上翻页，按q键退出。           less [文件名]

   1.6 wc
       统计文件的行数，单词数和字节数等信息。默认选项为“-l”。           wc [选项] [文件名]                  -c：文件字节数                  -l：文件行数                  -w：文件单词个数

   1.7 file 
       显示文件类型:  ASCII / Unicode 类型         file <文件名>

   1.8 du
       统计每个文件或目录的磁盘使用情况           du [选项] [文件或目录]                  -a：统计指定目录下每个文件及子目录占用的磁盘空间大小。                  -s：只统计指定目录或文件总共占用的磁盘空间大小。                  -h：显示信息时使用更人性化的容量大小单位。如：KB，MB，GB            --apprentice-size：统计文件或目录的真实大小，而不是占用磁盘空间大小。      


检索文件和目录
  

1. grep
   文件中查找并显示包含指定字符串的行，可用正则表达式匹配。        grep [选项] <查找字符串> [文件名]                -i：查找内容时忽略大小写。                -v：反转查找，即输出与查找条件不相符的行。
2. which
   查找命令或程序文件的绝对路径.       which [选项] [命令或程序命令]                -a：列出所有查找到的结果，而不是仅仅是第一个。
3. whereis
   查找指定名称的二进制文件 帮助文件或源文件所在的位置。       whereis [选项] [文件名]                   -b：只查找指定名称的二进制文件的所在位置。                   -m：只查找指定名称的帮助文件所在的位置。                   -s：只查找指定名称的源文件所在的位置。
4. find
   根据一定的条件在指定目录范围中递归查找需要的文件或目录。       find <搜索范围> <查找条件>              -name：按名称查找，可以使用通配符。              -size：按大小查找，可以使用KB，MB，GB等容量单位。              -type：按类型查找:
   f → 普通文件 
   d → 目录
   l → 链接
   b → 块设备 
   c → 字符设备.


管理文件和目录    2. mkdir
创建新目录    mkdir [选项] <目录名>      
1. touch
   - 文件存在:   更新文件的时间标记，
     - 文件不存在: 创建对应的空文件。           touch <文件名>

2. cp
   复制文件或目录，复制源是目录或多个文件时，目标必须是目录。       cp [选项] <源目录或文件> <目标目录或文件>            -f：覆盖目标同名文件或目录时不进行提醒，而直接强制复制。            -i：覆盖目标同名文件或目录时提醒用户确认。            -l：为源文件建立硬链接，而不是直接复制磁盘数据块。            -p：复制时保持源文件的权限，属主及时间戳等属性不变。            -r：复制目录时使用，递归复制所有文件及子目录。
3. mv
   移动文件或目录，可以在移动时改名。
   移动多个文件或目录时，目标必须是目录。       mv [选项] <源文件或目录> <目标文件或目录>              -f：覆盖目标同名文件时不进行提醒，二直接强制移动。              -i：覆盖目标同名文件或目录时提醒用户确认。
4. rm
   删除指定的文件或目录。       rm [选项] <文件或目录>              -f：在删除文件或目录时不进行提醒，而直接强制删除。              -i：在删除文件或目录时提醒用户确认。              -r：删除目录时使用，递归删除所有文件及子目录。
5. ln
   为文件或目录建立连接，硬链接不能用于目录，也不能跨硬盘分区。       ln [选项] <源文件或源目录> <链接文件位置>              -s：建立软链接即符号链接文件，默认为硬链接。              -f：若链接文件已存在，则直接强制覆盖。              -i：在覆盖目标链接文件时提醒用户确认。
6. chmod
   修改文件或目录的访问权限。       chmod [选项] <权限格式> <文件或目录>                 -R：递归修改指定目录下的所有文件，子目录的权限。


sudo chmod -R 777 /usr/local/mysql-5.7.11-osx10.9-x86_64/data/

data 文件夹 下  所有文件 及 子文件夹 都有777 权限.






1. chown
   修改文件或目录的所有权，可以同时修改文件的属主属组。       chown [选项] <[属主][:属组]> <文件或目录>                 -R：递归修改指定目录下的所以文件，子目录的所有权。
2. chattr
   修改文件的i节点属性，使用lsattr命令可以查看对应的属性，格式       chattr [+|-ia] <文件>                  +i：将文件的i节点属性设置为不可变，即i节点锁定。                  -i：去除设置的+i锁定标记。                  +a：将文件设置为只可追加内容，原有数据不能修改。                  -a：去除设置的+a锁定标记。      


压缩和备份管理    
1. tar
   将文件或目录备份打包，
   并通过选项gzip和bzip程序将包文件进行压缩，解压。        tar [选项] <包文件名> <指定备份的文件或目录>    
   -c：创建.tar格式的包文件。        -C：解包时指定释放的目标文件夹。        -f：表示使用归档文件。        -j：调用bzip2程序进行压缩或解压。        -p：打包时保留文件及目录的权限。        -P：打包时保留文件及目录的绝对路径。        -t：列表查看保内的文件。        -v：输出详细信息。        -x：解开.tar格式的包文件。        -z：调用gzip程序进行压缩或解压。
2. gzip
   创建.gz格式的压缩文件。   
   gzip [选项] <文件或目录>    
   -1：以最快速度优先的模式创建压缩文件。        -9：以最大压缩比优先的模式创建压缩文件。        -d：解压缩.gz格式的压缩文件。
3. bzip2
   创建.bz2格式的压缩文件。       格式：bzip2 选项 () <文件或目录>        -1：以最快速度优先的模式创建压缩文件。        -9：以最大压缩比优先的模式创建压缩文件。        -d：解压缩.bz2格式的压缩文件。
4. zip
   创建.zip格式的压缩文件。       bzip2 [选项] <压缩文件名> <文件或目录>        -1：以最快速度优先的模式创建压缩文件。        -9：以最大压缩比优先的模式创建压缩文件。        -r：递归压缩指定目录及其下所有文件，子目录。
5. unzip
   解压缩.zip格式的压缩文件。       unzip [选项] <压缩文件名>        -d：解压到指定的文件夹。        详细命令介绍请参考：RHEL 5基础篇—打包、压缩文件或目录

管理RPM软件包
    rpm 安装、卸载及查询系统中的RPM软件包。     rpm [选项] <软件名>     -i：安装新的RPM软件，参数要求是.rpm格式的软件包文件。     -U：检查更新现有的软件。     -e：卸载指定的RPM软件包，参数要求是已安装的RPM软件包的名称。     -q：查询系统内已安装的软件包相关信息，后面可以跟-l、-f、-p等子查询选项。     -v：输出详细信息。     -h：以“#”好标记显示安装进度百分比。     详细命令介绍请参考：RHEL 5基础篇—使用rpm包安装应用程序

管理用户和组 
1. useradd
   添加指定的系统用户。        useradd [选项] <用户名>        -d：指定用户的宿主目录位置。        -e：指定用户的账户失效时间，可使用YYYY-MM-DD的日期格式。        -g：指定用户的基本组名，也可以使用GID号。        -G：指定用户的附加组名，也可以使用GID号。        -M：不为用户建立并初始化宿主目录。        -s：指定用户的登录shell。        -u：指定用户的UID号，如果该UID已经被使用，则增加-o选项忽略掉并继续执行。
2. passwd
   设置系统用户的密码，及锁定，解锁用户账户。
   未指定用户名时及修改当前用户自己的密码。       passwd [选项] [用户名]        -d：清空指定用户的密码，仅使用用户名即可登录系统。        -l：锁定用户账户。        -S：查看用户账户的状态。（是否被锁定）        -u：解锁用户账户。
3. usermod
   修改指定系统用户的信息，大部分选项与useradd命令中的作用相同。       usermod [选项] <用户名>        -u：修改用户的UID号。        -d：指定用户的宿主目录位置。        -e：指定用户的账户失效时间，可使用YYYY-MM-DD的日期格式。        -g：指定用户的基本组名，也可以使用GID号。        -G：指定用户的附加组名，也可以使用GID号。        -M：不为用户建立并初始化宿主目录。        -s：指定用户的登录shell。        -l：更改用户的登录名称。        -L：锁定用户账户。        -U：解锁用户账户。
4. userdel 
   删除指定的用户账户。       userdel [选项] <用户名>        -r：删除用户后，也将该用户的宿主目录一并删除。
5. groupadd
   添加一个系统用户组       groupadd 选项 () <组名>        -g：为新建的组指定GID组标记号。
6. groupdel
   删除指定的系统用户组。       groupdel <组名>
7. id    输出指定用的神风标志信息，省略用户名参数时则输出当前用户的信息。       id [选项] [用户名]        -u：只显示有效的用户信息。        -g：只显示有效的组信息。        -n：只输出用户名称而不是数字标记。
8. users
   查看登录到当前主机中的用户。       user
9. su
   切换为另一个用户登陆shell环境，不指定用户名参数时默认切换为root。       su [-l] [目标用户名]        -l：使用目标用户的登录shell环境，该选项可简写为“-”        详细命令介绍请参考：RHEL 5基础篇—管理用户和组


管理文件系统    
1. df
   查看挂载的文件系统中磁盘空间的使用情况。        df [选项] [分区或挂载点]        -a：输出所有可见文件系统的信息，包括伪文件系统。        -h：显示时使用更人性化的容量大小单位，如KB、MB、GB等。        -i：查看分区中的i节点占用情况。        -t：只查看指定类型的文件系统信息。        -T：输出信息同时显示该分区的文件系统类型。
2. jstat命令——显示文件或文件系统的i节点状态。       格式：stat 选项 () 文件 ()        -f：显示文件所属文件系统的i节点状态，而不是文件本身的状态。
3. fdisk命令——查看磁盘分区，以及通过交互式界面为指定的磁盘进行分区设置。       格式：fdisk 选项 () 磁盘设备文件 ()        -l：显示指定磁盘的分区信息。未指定磁盘设备时，则显示已识别的所有磁盘信息。
4. mkfs命令——用户创建文件系统，即多磁盘分区进行格式化。       格式：mkfs -t 文件系统类型 () <分区>        -t：指定需要创建的文件系统类型。
5. fsck命令——检查和修复linux文件系统中的错误。       格式：fsck -yt 分区类型 () <分区>        -y：在所有提示确认的步骤自动回答“yes”。        -t：指定需要检查的分区的文件系统类型。
6. mount命令——挂载磁盘存储设备或网络共享目录。       格式：mount -t文件系统类型 () -o挂载选项 () <设备或网络共享目录> <挂载点目录>        -t：指定设备所使用的文件系统。        -o：指定挂载控制选项，如ro、rw、noexec、loop等。
7. umount命令——卸载已挂载的文件系统。       格式：umount  <设备位置或挂载点位置>
8. eject命令——卸载并弹出光盘以及收回光盘托架。       格式：eject 选项 ()        -t：收回已弹出的光盘托架。        详细命令介绍请参考：RHEL 5基础篇—管理系统磁盘及分区


管理进程与服务    
1. ps命令——以静态快照的方式输出当前运行的进程状况统计数据。        格式：ps 选项 ()        a：显示当前终端下的所有进程信息，包括其他用户的进程。        u：使用以用户为主的格式输出进程信息。        x：显示当前用户在所有终端下的进程信息。        -e：显示系统内的所有进程信息。        -l：使用长格式显示进程信息。        -f：使用完整的格式显示进程信息。
2. top命令：动态显示当前运行的进程信息，默认每3秒刷新一次。       格式：top 选项 ()        -d：指定动态信息的刷新时间隔，单位为秒，也可以使用ss.tt的格式。
3. pstree命令——以树形结构查看系统中的进程及相互关系。       格式：pstree 选项 ()        -a：显示进程对应的命令行。        -u：显示进程对应的用户名信息。        -p：显示进程对应的进程号信息。
4. kill命令——终止指定进程号的进程，PID可以通过ps等命令获得。       格式：kill 选项 () <PID号>        -9：强制终止进程。
5. killall命令——终止指定进程名的所有进程，可用于结束同名的多个进程。       格式：killall 选项 () <进程名>        -9：强制终止进程。
6. free命令——查看系统的内存、交互空间的使用情况。       格式：free 选项 ()        -b：以B为单位显示信息。        -k：以KB为单位显示信息。        -M：以MB为单位显示信息。
7. chkconfig命令——设置系统服务在不同的运行级别的自启动状态，以及添加、删除系统服务。       格式：chkconfig 选项 () <服务名> on或off ()        --level：指定控制服务的运行级别范围。        --list：查看当前系统中的服务自启动状态。        --add：添加新的系统服务。        --del：删除指定的系统服务。
8. ntsysv命令——提供一个交互的伪图形程序，用于设置各种系统服务在不同运行级别的自启动状态。       格式：ntsysv 选项 ()        --level：指定对应运行级别，数字选项对应init的不同模式，可以组合使用。        详细命令介绍请参考：RHEL 5基础篇—管理系统服务和进程

网络配置管理    
1. ifconfig命令——查看及临时设置网络接口参数，停用或激活网卡。        格式：ifconfig 网卡设备名 () ip地址 () down或up ()
2. ping命令——测试到目标主机的网络链接状态。       格式：ping 选项 () <目标主机名或ip地址>        -c：设置发送测试数据包的个数。        -s：设置发送测试数据包的大小，以字节为单位。        -i：设置发送每个测试数据包的间隔时间，单位为秒。
3. traceroute命令——跟踪到目标主机的路由途径。       格式：traceroute <目标主机名或ip地址>
4. mtr命令——融合了ping和traceroute命令优点的网络诊断工具，可动态刷新路径信息，按q退出。       格式：mtr <目标主机名或ip地址>
5. netstat命令——查看系统的网络链接状态的统计信息。       格式：netstat 选项 ()        -a：显示当前所有的网络连接信息。        -n：使用数字形式表示地址，端口信息。        -p：同时显示和每个网络连接关联的进程信息。（PID）        -t：显示TCP协议相关的网络连接信息。        -u：显示UDP协议相关的网络连接信息。        -r：查看系统的路由表信息。

其他常用命令    
1. man命令——查看命令、内核函数或配置文件等相关的帮助手册。        man <命令或函数或配置文件>
2. help命令——查看shell内部命令的帮助信息。       格式：help 选项 () 内部命令名 ()        -s：只显示概要帮助信息，通常只输出命令的格式。
3. clear命令——用于清屏，只保留一行命令提示符内容，也可以使用Ctrl+L快捷键。       格式：clear
4. alias命令——查看及设置命令别名，可以简化频繁使用的命令操作。       格式：alias 别名 ()=命令字符串 ()
5. unalias命令——取消已设置的命令别名。       格式：unalias 选项 () 别名 ()        -a：取消所有的命令别名设置。
6. uname命令——显示当前系统主机名，系统平台。硬件平台。内核版本，系统时间等信息。       格式：uname 选项 ()        -a：显示所有的相关信息。        -i显示硬件的体系结构类型。        -r：显示Linux系统的内核版本号。








cp
rm
  
rm -r testFolder
man


window Linux 常用命令.  诊断局域网网络故障非常有用


rout
tracert

ipconfig

arp

ftp

ipconfig

nbtstat

net


ping
 route
telnet
tracert 

pathping
winipcfg





iterm2  自动登录. telnet
1. Mac 电脑
2. 终端用 iTerm2 
3. 先写exp 格式的登陆脚本.   telnet.exp
4. 把脚本放到 /usr/local/bin下
5. 给脚本运行权限!!! 只能读写是不行的.`chmod +x 文件名路径
   `6. 去 iTerm 设置 → Profiles → 新建 
6. 输入 Name. 
7. send text as start:  输入脚本所在的完整路径.退出 

8. iTerm 菜单栏 → Profiles → 选择名字
或者 ⌘+o 快捷键 → 上下键选择 → 回车. 就登进去额.


比如 cisco 交换机.   要输入两次密码的.


#!/usr/bin/expect
set timeout 20

spawn telnet 172.19.16.46
// 交换机的 IP
send "\r"
// mac 下会多个提示 按回车就好了
expect "Password:"
//输入 vty 密码
send "IT@\r"

expect "Password:"
// 输入特权模式密码
//(Cisco telnet 的话 必须要输入两个不同的密码才能登陆的.)
send "IT@R\r"
interact






Command Center
  
cp
cp file file2
cp dir

rm
rm -f file
rm -rf dir

apt get

grep

rm -fr



df -h

 yum inatall update remove

ifconfig eth0






ls |more


或者 手动安装 tree 命令    就能以树形结构看文件目录了.




用s///和正则表达式就可以完成



perl 正则式表达:看




sed:




这三种形式一般都和 = 或 ! 搭配使用（其中 "=" 表示相匹配，在整条语句中读作 does，"!" 表示不匹配，在整条语句中读作 doesn't），并在左侧有待处理的标量变量。如果没有该变量和 = ! 操作符，则默认为处理 $_ 变量中的内容。举例如下：


$str = "I love Perl";

$str = m/Perl/; # 表示如果在 $str 中发现 "Perl" 字符串，则返回 "1" 否则返回 "0"。

$str = s/Perl/BASH/; # 表示将变量 $str 中的 "Perl" 字符串替换为 "BASH"，如果发生此替换则返回 "1"，否则返回 "0"。

$str ! tr/A-Z/a-z/; # 表示将变量 $str 中的所有大写字母转化为小写字母，如果转化发生了则返回 "0"，否则返回 "1"。


另外还有：


foreach (@array) { s/a/b/; } # 此处每次循环将从 @array 数组中取出一个元素存放在 $_ 变量中，并对 $_ 进行替换处理。

while (<FILE>;) { print if (m/error/); } # 这一句稍微复杂一些，他将打印 FILE 文件中所有包含 error 字符串的行。


Perl 的正则表达式中如果出现 () ，则发生匹配或替换后 () 内的模式被 Perl 解释器自动依次赋给系统 $1, $2 ...... 请看下面的例子：


$string = "I love perl";

$string = s/(love)/<$1>;/; # 此时 $1 = "love"，并且该替换的结果是将 $string 变为 "I <love>; perl"

$string = "i love perl";

$string = s/(i)(.)(perl)/<$3>;$2<$1>;/; # 这里 $1 = "i"，$2 = " love "，$3 = "perl"，并且替换后 $string 变为 "<perl>; love <i>;"


替换操作 s/<pattern>;/<replacement>;/ 还可以在末尾加上 e 或 g 参数，他们的含义分别为：


s/<pattern>;/<replacement>;/g 表示把待处理字符串中所有符合 <pattern>; 的模式全部替换为 <replacement>; 字符串，而不是只替换第一个出现的模式。

s/<pattern>;/<replacement>;/e 表示将把 <replacemnet>; 部分当作一个运算符，这个参数用的不多。


比如下面的例子：


$string = "i:love:perl";

$string = s/://; #此时 $string="ilove:perl";

$string = "i:love:perl";

$string = s/://g; #此时 $string="iloveperl"; 

$string = tr// /; #此时 $string="i love perl"; 

$string = "www22cgi44";

$string = s/(d+)/$12/e; # (/d+)代表 $string 中的一个或多个数字字符，将这些数字字符执行 2 的操作，因此最后 $string 变成了 "www44cgi88"。


下面给出一个完整的例子：


!/usr/bin/perl


print"请输入一个字符串!n";

$string = <STDIN>;; # <STIDN>;代表标准输入，会让使用者输入一字符串

chop($string); # 将$string最后一个换行的字符n删除掉

if($string = /perl/){

　　print("输入的字符串中有 perl 这个字符串!n";

}


如果输入的字符串含有 perl 这个字符串的话，就会显示后面的提示信息。


 


9.2 正则表达式中的常用模式

下面是正则表达式中的一些常用模式。


/pattern/  结果  

. 匹配除换行符以外的所有字符 

x? 匹配 0 次或一次 x 字符串 

x* 匹配 0 次或多次 x 字符串，但匹配可能的最少次数 

x+ 匹配 1 次或多次 x 字符串，但匹配可能的最少次数 

.* 匹配 0 次或一次的任何字符 

.+ 匹配 1 次或多次的任何字符 

{m} 匹配刚好是 m 个 的指定字符串 

{m,n} 匹配在 m个 以上 n个 以下 的指定字符串 

{m,} 匹配 m个 以上 的指定字符串 

 () 匹配符合  () 内的字符 

[^]() 匹配不符合  () 内的字符 

0-9 () 匹配所有数字字符 

a-z () 匹配所有小写字母字符 

[^0-9]() 匹配所有非数字字符 

[^a-z]() 匹配所有非小写字母字符 

^ 匹配字符开头的字符 

$ 匹配字符结尾的字符 

d 匹配一个数字的字符，和 0-9 () 语法一样 

d+ 匹配多个数字字符串，和 0-9 ()+ 语法一样 

D 非数字，其他同 d 

D+ 非数字，其他同 d+ 

w 英文字母或数字的字符串，和 a-zA-Z0-9 () 语法一样 

w+ 和 a-zA-Z0-9 ()+ 语法一样 

W 非英文字母或数字的字符串，和 [^a-zA-Z0-9]() 语法一样 

W+ 和 [^a-zA-Z0-9]()+ 语法一样 

s 空格，和 ntrf () 语法一样 

s+ 和 ntrf ()+ 一样 

S 非空格，和 [^ntrf]() 语法一样 

S+ 和 [^ntrf]()+ 语法一样 

b 匹配以英文字母,数字为边界的字符串 

B 匹配不以英文字母,数值为边界的字符串 

a|b|c 匹配符合a字符 或是b字符 或是c字符 的字符串 

abc 匹配含有 abc 的字符串 

(pattern) () 这个符号会记住所找寻到的字符串，是一个很实用的语法。第一个 () 内所找到的字符串变成 $1 这个变量或是 1 变量，第二个 () 内所找到的字符串变成 $2 这个变量或是 2 变量，以此类推下去。  

/pattern/i i 这个参数表示忽略英文大小写，也就是在匹配字符串的时候，不考虑英文的大小写问题。 

 如果要在 pattern 模式中找寻一个特殊字符，如 "*"，则要在这个字符前加上  符号，这样才会让特殊字符失效 

 


下面给出一些例子：    


范例 说明 

/perl/ 找到含有 perl 的字符串 

/^perl/ 找到开头是 perl 的字符串 

/perl$/ 找到结尾是 perl 的字符串 

/c|g|i/ 找到含有 c 或 g 或 i 的字符串 

/cg{2,4}i/ 找到 c 后面跟着 2个到 4个 g ，再跟着 i 的字符串 

/cg{2,}i/ 找到 c 后面跟着 2个以上 g ，再跟着 i 的字符串 

/cg{2}i/ 找到 c 后面跟着 2个 g，再跟着 i 的字符串 

/cg*i/ 找到 c 后面跟着 0个或多个 g ，再跟着 i 的字符串，如同/cg{0,1}i/ 

/cg+i/ 找到 c 后面跟着一个以上 g，再跟着 i 的字符串，如同/cg{1,}i/ 

/cg?i/ 找到 c 后面跟着 0个或是 1个 g ，再跟着 i 的字符串，如同/cg{0,1}i/ 

/c.i/ 找到 c 后面跟着一个任意字符，再跟着 i 的字符串 

/c..i/ 找到 c 后面跟着二个任意字符，再跟着 i 的字符串 

/cgi ()/ 找到符合有这三个字符任意一个的字符串 

/[^cgi]()/ 找到没有这三个字符中任意一个的字符串 

/d/ 找寻符合数字的字符，可以使用/d+/来表示一个或是多个数字组成的字符串 

/D/ 找寻符合不是数字的字符，可以使用/D+/来表示一个或是更多个非数字组成的字符串 

/*/ 找寻符合  这个字符，因为  在常规表达式中有它的特殊意思，所以要在这个特殊符号前加上  符号，这样才会让这个特殊字符失效 

/abc/i 找寻符合 abc 的字符串而且不考虑这些字符串的大小写 


 


9.3 正则表达式的八大原则

　　如果在 Unix 中曾经使用过 sed、awk、grep 这些命令的话，相信对于 Perl 语言中的正则表达式(Regular Expression)不会感到陌生。Perl 语言由于有这个功能，所以对字符串的处理能力非常强。在Perl语言的程序中，经常可以看到正则表达式的运用，在 CGI 程序设计中也不例外。


　　正则表达式是初学 Perl 的难点所在，不过只要一旦掌握其语法，你就可以拥有几乎无限的模式匹配能力，而且 Perl 编程的大部分工作都是掌握常规表达式。下面给大家介绍几条正则表达式使用过程中的 8 大原则。 


　　正则表达式在对付数据的战斗中可形成庞大的联盟——这常常是一场战争。我们要记住下面八条原则：


· 原则1：正则表达式有三种不同形式(匹配(m/ /)，替换(s/ / /eg)和转换(tr/ / /))。


· 原则2：正则表达式仅对标量进行匹配( $scalar = m/a/; 可以工作; @array = m/a/ 将把@array作为标量对待，因此可能不会成功)。


· 原则3：正则表达式匹配一个给定模式的最早的可能匹配。缺省时，仅匹配或替换正则表达式一次( $a = 'string string2'; $a = s/string/ /; 导致 $a = 'string 2')。


· 原则4：正则表达式能够处理双引号所能处理的任意和全部字符( $a = m/$varb/ 在匹配前把varb扩展为变量；如果 $varb = 'a' $a = 'as'，$a = s/$varb/ /; 等价于 $a = s/a/ /; ，执行结果使 $a = " s" )。


· 原则5：正则表达式在求值过程中产生两种情况：结果状态和反向引用： $a= m/pattern/ 表示 $a 中是否有子串 pattern 出现，$a = s/(word1)(word2)/$2$1/ 则“调换”这两个单词。


· 原则6：正则表达式的核心能力在于通配符和多重匹配运算符以及它们如何操作。$a = m/w+/ 匹配一个或多个单词字符；$a = m/d/" 匹配零个或多个数字。


· 原则7：如果欲匹配不止一个字符集合，Perl使用 "|" 来增加灵活性。如果输入 m/(cat|dog)/ 则相当于“匹配字符串 cat 或者 dog。


· 原则8：Perl用 (?..) 语法给正则表达式提供扩展功能。（这一点请同学们课后看相关资料）


想要学习所有这些原则？我建议大家先从简单的开始，并且不断的尝试和实验。实际上如果学会了 $a = m/ERROR/ 是在 $a 中查找子串ERROR，那么你就已经比在 C 这样的低层语言中得到了更大的处理能力。




apt-get update是更新仓库数据
◦ upgrade不是更新系统？









Git 教程:
基本命令和操作

新建仓库: 先网站上新建  再 clone到本地



git clone + 仓库网址 : 已经有个 远程仓库.  克隆一个到本地电脑

git clone https://github.com/Xu-Jian/DSM.git
 
 
 
 二、 Git 常用命令

1) 远程仓库相关命令
检出仓库：        $ git clone git://github.com/jquery/jquery.git
查看远程仓库：$ git remote -v
添加远程仓库：$ git remote add name () url ()
删除远程仓库：$ git remote rm name ()
修改远程仓库：$ git remote set-url --push name () newUrl ()
拉取远程仓库：$ git pull remoteName () localBranchName ()
推送远程仓库：$ git push remoteName () localBranchName ()

*如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：
$git push origin test:master         // 提交本地test分支作为远程的master分支
$git push origin test:test              // 提交本地test分支作为远程的test分支
 
 
 
 
 
 
 
 
 
 
 
 
 
 



 

PS :GIT的使用和SVN这类中心式的架构有很大不同。要把本地项目创建到GIT SERVER上，需要费点周折。

简单的说可以按照如下步骤：

1.先在本地创建项目，有个项目目录

2.然后在本地的这个项目目录中执行git --bare init进行初始化。

3.然后将需要提交的文件提交到本地

4.然后将项目目录COPY到服务器上，只COPY  .git 目录就行，其他工作目录不用COPY的。

5.在本地就可以推送到远程服务器上了。

还有一种方法：

如果本地初始化的时候使用的是git init，那么推送就会出现问题。

解决方法是将本地的目录全部COPY到服务器上。

然后再服务器对应目录下面执行：

git config --bool core.bare true
接着删除掉除.git目录之外的所有文件和目录即可。
这样本地就能顺利推送了。

当然直接使用

git clone --bare hello hello.git
这样直接导出裸库，然后将hello.git 这个目录直接上传到服务器上也可以。不过地址需要加上hello.git这个的目录。




设备:
- 群辉NAS:   IP : 192.168.1.7
- 路由器:    IP : 192.168.1.1 网件 6300  刷 dd-wrt.



群辉:
- 下载+启用+打开  radius server 这个套件

设置:
-   验证端口: 1812
-   选择验证用户所针对的来源  → 本地用户

客户端:
 新增 - 名称: 随便填
- 秘钥: 大于8位  这里: 12345678
- 来源 IP:就是哪个路由器的 wifi 要开启 验证才能登录.
单一主机: 192.168.1.1 



路由器设置

- 不需要开启 radius 功能: 无线 → radius → 启用 →

- 只需要:无线 → 无线安全 → 安全模式: → wp2 enterprise
服务器地址 192.168.1.7
端口 1812
共享秘钥 12345678



手机
- 选择wifi  连接. 
- 输入 nas 中已经创建好的账号密码.
- 安装证书.


通过 nas 账号 来管理 wifi权限.

1 ():  https://www.synology.cn/zh-cn/knowledgebase/tutorials/592
2 ():  smb://xujian.myDS.me
3 ():  https://www.synology.cn/zh-cn/knowledgebase/faq/299

















Man
Example:    man ls 

- 所有命令的帮助文件位置
  ls /usr/share/man
  man1   man5   man7   man9   whatis
  man4   man6   man8   mann

  如: 
  man1 → awk.1
  man8 → ifconfig.8

Man用法:
man 命令基于 less命令.less 能用的操作都能在 man 下使用
⥎ → 下页;  ⌃+d → 下半页; ↵ → 下行; g  → 首行;   q  → 退出
b  → 上页;  ⌃+u → 上半页; k  → 上行; G  → 尾行;  g22 → 指定行

/ 顺序搜索                不区分大小写
? 倒序搜索                n/N 上/下一个搜索结果

Man命令 组成 (分不同的章节)

1. General Command Manual 普通命令 
2. 系统调用
3. 函数库
4. 特殊文件 /dev
5. 文件格式
6. 游戏用
7. 附件
8. 系统管理员命令  ifconfig

如:
man ls       → LS(1)
man ifocnfig → IFCONFIG(8)

NAME           命令全称
ls - list directory contents

SYNOPSIS   语法格式

ls [-ABCFGHLOPRSTUW@abcdefghiklmnopqrstuwx1] [file ...]

[] 可选项.
-AB… → 前面要有- 


<> 必须提供项
…  同类的内容可出现多个
a|b|c 多选一. 必须选一个.


Description   命令的描述
option    选项
Examples   使用示例
Author   作者
Bugs 
SEE Also 参考





🔸 lsof
    list open file
    看谁在使用某个文件 (也就是某个文件的 相关进程)
    lsof /bin/bash
    这里列出两个  就说明有两个用户/端口? 打开了 bash 这个进程


PID 程序 杀进程

活动监视器 看 PID + Port
端口 默认是不显示的 
→ program name 右键 选择 port 才有.

 




Echo

**查看&修改文件.

- 覆盖文件写入:
  echo aaa > a.txt
- 增加写入 (文件尾部 新建一行增加)
  echo aaa >> a.txt
- 增加分行写入 
  echo -e "xujian\nxujian0219@126.com" >> a.txt
  echo 下面 ! 是特殊符号  要\! 才能输出 !号.

- 多行文字输入: 
  cat >> 文件 <<EOF
  直接输入内容.就可以了. 可以输入很多行!!!!!!
   Example:
  cat >> /root/a.txt <<EOF
  123456789
  bbbbbbbb
  FFFFFFFFFFFFFFFFFFFFFFF
  EOF
  //作用: 在a.txt文件后面加上三行代码。

 Cat 和 EOF
- cat 文本输出命令，观看某个文件的内容；
- EOF: ”end of file"，表示文本结束符。

结合这两个标识，即可避免使用多行echo命令的方式，并实现多行输出的结果。

注意EOF只是标识，并不是固定不变的也可以用别的符号代替比如EEE等等。
Cat << EOF  ...EOF 最后一个EOF一定顶格写，还有相关命令一定要顶格写.




TOP / Htop - Mac OS
显示进程(动态)
htop 源于top. 功能更加强大. brew install htop

效果图: 
上部分:
CPU 内存 交换内存

Middle: PID  进程的标识号
USER 运行此进行的用户.
PRI  进程的优先级.??
NI   进程的优先级??
VIRT 虚拟内存占用.??
RES  物理内存占用.??



S: 进程运行状态:
R → 正在运行
S → 休眠
Z → 僵死状态

M%:  物理内存占用的百分比.

Buttom: 
快捷键 F1-F10 对应的功能


搜索进程: F3 
排序方式: F6 
退出:     F10























IT 技能:

日常监控. 数据备份. 
日志分析.
Git/svn
IDC. 

问题排查: troubleshooting .

openstack 云操作系统.

Redis: 内存上的数据库. 

网络攻防

Redis
SSL / TLS  公钥加密.


端口 - 程序 netstat
找到使用某个端口的程序
可以使用 两个命令 netstat (推荐) 和 lsof.

- netstat
查找某个固定端口
netstat -an | grep 3306

显示所有在用端口.很多 .不建议用.
netstat





❤️ 网络常识
WAN, LAN, VLAN


HTTP:
专门用来传输 web内容(css js html ...)的协议. 网站一般都 http:// 开头.

http 版本: 常用 http 1.1  ;  gmail 用的 http2.0

HTTP 是基于 TCP的. 
HTTP 对TCP的使用 分两种: 短连接 和 长连接/持久连接/keep-alive
http1.1 默认用的 长连接. 
英文建立TCP连接是有 时间成本和cpu成本的..
现在登录一个网站 常常要下载很多css/js 所以默认持久连接.


SSL/TLS:
“Secure Sockets Layer” “安全套接层
由于 http是明文. 容易被黑. 被窃取.  有了加密需求.就有了ssl.
后来把 ssl 改名成 tls.Transport Layer Security”，“传输层安全协议”。
ssl tls 都是一个东西..

HTTPS:
就是 http 和 ssl/tls 的组合.



对称加密
加密”和“解密”使用【相同的】密钥。这个比较好理解。就好比你用 7zip 或 WinRAR 创建一个带密码（口令）的加密压缩包。当你下次要把这个压缩文件解开的时候，你需要输入【同样的】密码。在这个例子中，密码/口令就如同刚才说的“密钥”。




非对称加密
“加密”和“解密”使用【不同的】密钥。这玩意儿比较难理解，也比较难想到。当年“非对称加密”的发明，还被誉为“密码学”历史上的一次革命。
这里就不介绍了...





CA 证书
















❤️ 自动化运维
一系列手工执行的操作. 用脚本或者工具连接起来.
1. 环境自动化
不同的部门不同的开发环境.

2. 部署自动化
Script → Auto tools → Cloud → Container

1. 最初 ssh 到服务器. 下载软件开始安装. 重启服务器 .
如果经常需要升级. 就会很麻烦. 
于是大家来写 shell 脚本. 
脚本好用. 但是 代码量大. 不好维护.

1. 部署脚本 迁移到了 puppet. 使用方便.易维护.

2. 私有云/公有云. 部署方式又有了变化.  war包. rpm包. image...
部署虽然简单了  但是管理各种包.... 麻烦.

1. 容器.  在 image 基础上.  部署自动化是解决了.

3. 监控自动化
一般用 zabbix .  有故障 可以自动警告.



















VPN
VPN: Virtual Private Network 即虚拟专用网络

是一条穿过混乱的公用网络的安全、稳定隧道。
这条隧道可以对数据进行几倍加密达到安全使用互联网的目的。

VPN是对企业内部网的扩展，可以帮助远程用户、公司分支机构、商业伙伴及供应商同公司的内部网建立可信的安全连接，
VPN主要采用隧道技术、加解密技术、密钥管理技术和使用者与设备身份认证技术。

Win7 VPN 架设
控制面板  → 网络连接 → 文件(左上角)  → 新建传入连接 
→ 添加用户 →允许用 vpn 连接

关于 连进来电脑的 ip 可以用 本地的 dhcp 服务器 或者 搭建的时候手动配置.
端口映射 1723 映射下就好了.



内网穿透一: Ngrok
搜索 Ngrok 服务器分享 可能有别人免费分享的服务器.

1. 官网下载客户端  解压 得到一个软件包.
2. 把解压出来的包 放到你喜欢的位置. 要一直保留的
3. cd 到 安装包位置
4. Terminal:   ./ngrok http 800  
   这个就是开放本机800端口到互联网
   前体是本地可以访问 127.0.0.1:800/


ngrok by @inconshreveable                                     (Ctrl+C to quit)

Tunnel Status                 online
Version                       2.1.3
Region                        United States (us)
Web Interface                 http://127.0.0.1:4040
管理页面  可以看到有哪些链接!!! 以及 请求的 url
Forwarding                    http://edfcd700.ngrok.io -> localhost:80
Forwarding                    https://edfcd700.ngrok.io -> localhost:80
随机给你生成的二级域名. 访问这个网站就是直接访问你本机的80端口 也就是默认 Web 网页!!!

Connections                   ttl     opn     rt1     rt5     p50     p90
                          0       0       0.00    0.00    0.00    0.00

顶级域名绑定:(付费可用)
域名购买那里 cname 解析到 ngrok.com 就可以.

转发到局域网内其他机器
./ngrok 172.19.16.16:80

TCP 端口转发
也就是外网可以ssh 到本机了.
./ngrok -proto=tcp 22

采用自定义域名(不确定) steven-mbp.ngrok.com 转发到本机8080
./ngrok -subdomain Steven-mbp 8080

内网穿透二: FRP

Github 官网(cn) (https://github.com/fatedier/frp/blob/master/README_zh.md)
FRP/Ngrok 等等内网穿透 一般都是用反向代理.
FRP Mac 下载: frp_0.8.1_darwin_amd64.tar.gz 

原理简介:
- 服务器一台:A 有固定IP.
- 本地一台:B 能上网就可以!
- 别人电脑:C 
- c要连A. 就必须通过b 再转到A.

FRP免费服务器1 (http://getfrp.yzxx-soft.com/)  FRP免费服务器2 (https://tunnel.mobi/index.html)

FRP 软件使用
百度云下载地址 (https://pan.baidu.com/s/1jIc4Epw#list/path=/frp/linux&parentPath=/frp)安装包. 一般有4个文件.
别人提供服务器的话:只需保留本地的两个文件.其他delete.
- 两个放在本机.
- 两个放在服务器.
接下来就 安装别人提供的信息 进行配置.

最后终端 CD到解压目录 → 执行 ./frpc -c frpc.ini

通过 ssh -oPort=6000 {user}@x.x.x.x 测试是否能够成功连接服务器A（{user}替换为服务器A上存在的真实用户），或通过浏览器访问自定义域名验证 http 服务是否转发成功。


重点注意:
FRP 和 Ngrok 区别:
Ngrok 的客户端是 不一样的. 里面集成什么认证. 反正和服务器是一一对应的.
Ngrok 的服务器提供商有不少. 他们各自的客户端是不通用的.














半/全 双工
半双工: 只能发送或者接收.  → 对讲机. 只能一边说话
全双工: 可同时发送和接收.  → 电话机. 能同时说话

广播地址
给同一个网络内的所有其他主机发送数据包.


Localhost
本地主机电脑的意思.
127.0.0.1  → 是 IPv4 的 loopback 接口
::1        → 是 IPv6 的 loopback 接口.

将web服务器上安装的web浏览器指向http://localhost


Hosts 文件

网址 和 IP 建立关联的数据库.
*浏览器 访问 网站之前,必须先对 Hosts 文件进行检查. 
-  找到:  就立刻打开对应ip.
-  没找到 提交给 DNS 域名解析服务器

Mac 的 host 文件路径:    /etc/hosts 
  1 ##
  2 # Host Database
  3 #
  4 # localhost is used to configure the loopback interface
  5 # when the system is booting.  Do not change this entry.
  6 ##
  7 127.0.0.1   localhost
  8 255.255.255.255 broadcasthost
  9 ::1             localhost

Hosts 文件作用:
1. 加快域名解析! → 提高访问网站速度.
经常访问的网站 可以直接通过 host 文件,配置 域名和 ip 的映射关系

1. 屏蔽网站 (域名重定向)
很多网站 不经用户同意就安装各种插件到你电脑.
可以把这些网站.映射到 0.0.0.0  这样他们就访问不internet 网了.
如: 0.0.0.0 www.baidu.com

很多破解软件用到这个文件的原理就是:
软件私底下是会给某个网址(比如xxx.com)发数据的.这些数据可以判断你的软件是否是盗版/是否激活了.
如果你软件过期了 xxx.com的服务器 就会把你的软件 锁住.不让你用.. 
xxx.com 肯定是有个IP的. 电脑其实是根据IP来发消息的, 
所以只要把xxx.com 的IP 改成一个无效的IP. 比如 127.0.0.1
这时候 软件 再给xxx.com偷偷发数据 就会发到 127.0.0.1 这个IP. 
127.0.0.1 收到莫名其妙的软件给它发消息.当然不会理它了. 
本地软件就不知道自己是否过期了. 你也就能继续用了...

.





NTP
互联网 是建立在时间标准上的. 没有一个统一的时间.就无法正常交流.
比如中国是utc +8 时间的 早上10点
日本是 utc +7的 早上9点.
虽然一个是 9点 一个是10点 不一样.
但是 utc +7 的9点 就是 对应 utc+8  的10点.
这两个时间 在电脑看来是 一样的.


链路聚合

一个路由器 同时接两根宽带.比如电信30M 联通20M 达到网速叠加50M的效果....
不要问我为什么 不直接换根更快的宽带 比如直接一根100M的...













❤️ 网络协议
OSI七层模型
物理 / 数据链路 / 网络 / 传输 / 会话 / 表示 / 应用
物理层:  0101比特流           中继器                信号发送和放大
链路层:  双方MAC地址       二层交换机          内部数据转发  
网络层:  双方IP地址            路由器/三层交换  外部数据转发   
传输层:  TCP/UDP 端口                               确保数据可靠传输                                    
会话层:  通信建立 & 断开 & 保持时间
表示层:  原始数据(文字/图像/声音)和 网络数据格式之间的转换 
应用层:  电子邮件. 文件传输. 网页浏览. 远程登录

TCP/IP 五层模型
1.  物理层: 硬件
2.  链路层: 网络接口层
3.  网络层: 互联网层 ip icmp 
4.  传输层: tcp udp
5.  应用层: 端到端的协议!!!   Telnet / FTP.. 应用程序一般是一个用户进程.  

1-4层 都是在内核中进行的.
第五层的数据可以不经过第四层直接到第三层. 
如 ping 就是 应用层(某个进程) 直接到 网络层的 icmp.


IP / ICMP
IP: 跨网传送数据包.

ICMP: 
internet 操作是由路由器严密监控的.
当路由器端 处理报文发生意外时,就会通过ICMP 报告给发送端.
如 IP包没有到达目的地. 必须给发送方一个ICMP包. 注明丢包原因

ICMP 目标不可达
ICMP 重定向
ICMP 超时
ICMP 回送:  ping 用的就是这个.

TCP / UDP
TCP: 有连接的传输协议. 传输慢. 能处理数据丢包. 数据传输顺序.保证对方能收到所有数据. UDP: 无连接的传输协议. 传输快. 数据发出去就可以了. 损失一些数据也无所谓. 比如网络视频直播.要求的就是快!不卡. 就是你丢失一些数据. 最多也就是视频画面某些像素缺失.视频模糊一点罢了.

TCP:  具体选项 . 只有0/1两种值.代表不同的意思
SYN:1  建立连接.
ACK:1  确认回答.
URG:1  数据包中有需要紧急处理的数据
RST:1  TCP连接出现异常. 需要强制断开连接.
FIN:1  数据传输完毕. 希望断开连接.

TCP 进程:
双方打开连接(三次握手) → 发送数据 → 双方关闭连接(四次挥手)


SYN: 发送序列号
ACK: 确认序列号
这两个 都只有32字节. 无法记录更大的数值.
传输过程中. 不正确的ACK 的数据包会被丢弃.正确的才会被接收.
同样是你的电脑.  建立连接后 . 如果你故意伪造个 ack 不正确的数据包 发给对方.对方是不会接收的!!



TCP 三次握手

握手目的: 建立连接. 分配资源. 初始化序列号.

SYN 请求连接. ACK 收到请求. 用 SYN 和 ACK 来保证安全可靠的传输.

1. 客户端发送 SYN 包告诉 服务器 我的初始序列号是 X.
2. 服务器收到SYN包. 需要回复给客户端一个 ACK确认包. 说服务器收到了.
3. 服务器也要告诉客户端 自己的初始序列号. SYN包: 值是Y
4. 客户端收到后 回复服务器一个 ACK 确认包.

三次握手就完成了...  这么简单 就是序列号的问题.

TCP 四次挥手











初始化序列号

初始化序列号.XY 不固定主要是为了安全.
不然黑客  很容易获取到 你与其他主机之间通信的初始化序列号.
然后猜出后续的序列号. 伪造序列号进行攻击

初始化序列号随机生成算法:
ISN = M + F (localhost , localport , remotehost,remoteport)
M是一个计时器. 每4毫秒 +1.
F 是一个 Hash 算法. 根据 源IP.目的IP.源端口, 目的端口. 生成的一个随机值.
要保证 hash 算法不被外部轻易的推算出. 用MD5 算法是一个选择.















ARP / RARP
ARP:   通过 IP地址     获取 MAC地址
RARP: 通过 MAC地址 获取 IP地址
ARP:  内网电脑之间, 外网路由器之间. 

ARP: ARP请求 + ARP响应
大方向上有IP就可以发送数据包, 其实两个设备之间在底层的通信是通过MAC地址实现的.

ARP 表
电脑都有个arp 表的. arp -a
默认是自动更新的. 当然你也可以手动指定那个IP 对应的哪个MAC地址.







SNMP

SNMP：“简单网络管理协议”, 用来采集 服务器/路由器 等设备的各种数据以便网络设备的管理。
SNMP被设计为工作在TCP/IP协议族上。SNMP基于TCP/IP协议工作.

温度 Fan,cpu,Memory,I/O,存储 网络吞吐 进程数量等
被检测的服务器 + 网管工作站.
服务器上启动 SNMP 协议. 客户端上登录进行监控.

SNMP的基本思想：为不同种类/型号/厂家的设备，一个统一的接口和协议，使得管理员可以是使用统一的外观面对这些需要管理的网络设备进行管理。

管理员需要向设备获取数据，所以SNMP提供了“读 GET ”操作；
管理员需要向设备执行设置操作，所以SNMP提供了“写 SET ”操作；设备需要在重要状况改变的时候，向管理员通报事件的发生，所以SNMP提供了“报警 Trap”操作。





DNS
数字IP . 和 英文网址之间的 自动转换.

DHCP
所有电脑都需要有IP. IP 要么手动设置. 要么就自动获取.
自动获取 就是靠的 DHCP服务.


NAT
内网的 私有IP地址 . 在互联网上 使用路由器的公网IP地址 的技术.



FTP / SMB
文件传输: 
FTP 使用两条TCP连接. 一条控制. 一条传输.


Telnet / SSH
Telnet 利用TCP 建立的一条连接. 发送文字命令.
给交换机/路由器等设备进行设置.

SSH: 加密远程登录系统.
TELNET 登录无需密码. 容易被窃听和入侵.
用了SSH . 就可以加密通信设置.即使信息被窃听 对方获取到的也就是加密后的数据.无法还原真实数据.








❤️ 网络命令
ping
基于 TCP/IP.
 -t / -l /-n  可以指定时间. 数据包大小 . 执行次数. 
Ping 使用技巧
Ping不通不一定网络有问题.  防火墙和路由器可以设置 过滤 ping 数据包的功能. 
1. ping 127.0.0.1     本机网卡是否正常.
本地TCP/IP协议的安装运行是否正常.
Ping 是基于TCP/IP协议的. 这个协议都没安装.或者被改坏了. 那自然就网络出错了.

1. ping 本机IP     断开本机网线 . 用别的电脑
看看是不是 IP冲突了. 也就是 别的电脑也设置成了你的IP.

1. ping 其他IP
子网掩码 / 网卡配置 / 网线 

1.  ping 网关
外网的数据都是结果网关的. ping 网关都不通.   网关死机了. 还是本机到网关的线路不通.

1. ping 外网IP
正常就是能上网. 不正常.... 应该就是网关之外的问题. 要么就是运营商的问题了. 不过这个概率很小.. 

1. ping localhost
localhost 是 127.0.0.1的 别名. 这个是在 host 文件中设置的.
不通的话 就看 host文件是否有问题.



ipconfig
显示当前TCP/IP 个 各种配置.
ipconfig /all

Tracert
路由跟踪.  实用程序.
用于确定 IP数据包到达目的地 所用的路径.

用TTL . 和 ICMP错误消息 来确定 数据是怎么传输的.
先发送 ttl 为1 . 这样第一个路由器就会丢弃改数据包. 然后放回一个ICMP. 这样就获取到了这个路由器的IP地址.
然后发送 ttl =2 ....   ... 等等...
这样就获得 数据到达目的地经过的所有路由器了.

netstat
按照协议. 分别统计数据. 

route
显示和修改 本地路由表.

不要以为只有路由器才有路由表.
本地电脑. 数据发出去前. 也需要先判断目的IP地址是 内网还是外网.
这个判断 当然用的是 本地路由表了...














❤️ 网络安全
防病毒

攻击手段
iptables 路由表
rootkit
root 管理员权限.
kit 软件/工具.

恶意软件吧. 为了获取 系统管理员权限的.

scan
扫描么.
namp 端口扫描.

syn-flood (过时)
SYN洪泛. 一种拒绝服务的攻击.
TCP 三次握手 首先发 syn. 请求建立连接.

海量的 syn 信息会耗尽服务器资源.
电脑端口是有限的. 海量的非法 syn 就会需要海量的端口.
导致合法的 syn 也分配不到端口. 连接不上服务器.

现在的TCP/IP 没有上面的限制了. 这种攻击也就无效了.













❤️ 网络硬件设备

思科交换机
路由器
防火墙




Console 配置线
第一次使用  必须用设备线进行配置.

fit 模式 只能用 相应的 ac 控制器来管理
fat 模式 可以用 console
telent / ssh  web 网管登陆  nms 登陆

硬件:  console 配置专用线 :  用串口+网线  或者 usb+ 网线
软件:  securecrt7.3.4  或者 iTerm终端(Mac OS)

连接设备和电脑   打开超级终端  就能进去了, 进去之后设置telent远程登录功能 方便以后管理.

命令不区分大小写

用户视图 权限小
系统试图 权限大  命令:  system-view
退出当前视图/断开ap设备连接 quit
返回用户视图  return
?  在线帮助


快速命令输入
save startup system-view
sa  直接保存
sy 系统视图
undo  禁用某个功能

空格  下一屏
回车 下一行

console 口 缺省配置
速率 9600 bit/s
流控  校验 无  停止位 1  数据位8















❤️ 日志 log

系统操作. / 程序操作 的日志都有记录.
NTFS 也是带有 文件日志的.

路由器. 服务器 都带有日志的.

人员登录...

进程开启/关闭..









机房维护+监控




❤️ KVM / ESX
Kernel Virtual Machine

能够在单个服务器硬件平台上运行多个虚拟机 (VM) 的能力在如今的 IT 基础架构中实现了了成本、系统管理和灵活性等方面的优势。
在单个硬件平台上托管多个虚拟机，可减少硬件开支并帮助最大限度降低基础架构成本，比如能耗和制冷成本。


支持将正在运行的虚拟机从一个物理主机迁移到另一个主机，以满足硬件或物理场所问题的需要，或者通过负载平衡最大限度提高性能，或者应对日益增长的处理器和内存需求。












❤️ AD域

域组成: 域控制器 + 成员服务器(邮箱/数据库/DNS/DHCP..) + 客户端

作用:  精细控制 NTFS文件权限!!!!


域/工作组区别.








❤️ 邮件服务器
Exchange 微软的邮件系统.

邮箱协议 SMTP POP3 IMAP

SMTP  POP3 IMAP. 都是 mail server 上的一个服务. 
smtp 发邮件  pop3/ imap 收邮件.
- SMTP:
简单邮件传输协议.“Simple Mail Transfer Protocol”
属于TCP/IP. 

- IMAP:
交互式邮件存取协议Internet Mail Access Protocol
客户端的操作 会 同步到服务器上. 

- POP3 IMAP区别:
POP3 比较老. 邮件会下载到本地. 服务器上会删除.
IMAP. 比较新. 邮件会复制都本地. 服务器上会保留.



垃圾邮件

垃圾邮件泛滥:
SMTP 服务器之间缺乏有效的发送认证机制.

垃圾邮件识别:
收到邮件后根据一定条件进行识别.耗费大量服务器资源.

如果能在信件到达服务器之前就采取手段就能大大提高服务器效率.
如: IP 反向解析验证技术

sina.com outlook 等等 都采用了 垃圾邮件识别技术 + IP 反向解析验证技术


PTR (IP反向解析) :
对方邮箱服务器安全性高的话会对发件方进行 IP 反向解析验证.
解析成功 就接受你的邮件.  不然就退信(拒收邮件).
一般 国外的邮箱 会有这种需求.

反向解析是: 对方服务器干的事情.
如果我们没做反向解析.那么对方服务器的反向解析验证 就会失败.
对方服务器.以:我们是不明发送方 拒绝接收我们发出的邮件.

这也就是我们排除其他原因后(被对方列入黑名单/ 没有 mx 记录/ 使用动态 ip) .无法向 sina.com hotmail.com 发信的原因.


例: QQ 到 GG 公司拜访.  
QQ :      我们的邮件服务器.
GG :      对方的邮件服务器.
ITR 公司: 邮件通信时使用的 HELO 域名.(不是邮箱域名)
名片电话:  我们邮件服务器出口的 公网IP地址.
1. QQ递上 自己的名片.
   名片内容: ITR 公司. + 电话号码

1. GG 公司: 对 QQ 的来历做简单身份调查.

   1.1 打电话给名片上电话号码的归属:电信局进行查实.

       - 电信局:这号码 不是 ITR 公司的. 拒绝访问.
         - 电信局:这号码 是   ITR 公司的. 进一步调查.

           - 打电话给 ITR 公司的注册机构查询.
             这个公司确实有这个号码.那就接受访问.
             这个公司没有这个号码,拒绝访问.



如何做反向解析

1. 公司有固定的 公网 IP 地址.
2. 可用的域名 (域名最好不要被别的服务用)
如 有个 lunch-time.com 的域名.
可以要求 域名注册商 给您添加一个  okmail.lunch-time.com 的域名.
并把 a 记录 指向您的 smtp 服务器出口公网 ip 地址.
与: 您的固定 IP 所属 ISP 联系.要求 为您的 ip 反向解析到
okmail.lunch-time.com
完成后 把自己的 SMTP 服务器的 helo 域名 改成 okmail.lunch-time.com 


反向解析是否成功:
nslookup -qt=ptr yourip
 看返回信息的结果.



SPF
sec

PTR:   ip 解析成域名.

spf
国外发邮件. 



网关
负责协议的转换 和 数据的转发.
网关 和 路由器是可以分开的. 路由只是选择路径. 只是OSI中的 第三层.
网关负责 4-7层. 也就是 传输层到应用层 的数据进行转换和转发的设备.
代理服务器 / 防火墙 都算是网关类的 设备..






数据封装
原始数据是没有任何头部信息的 .
OSI7层 从7层到第一层 . 每层都会给原始数据 加一些头部信息. 这就是封装.



HTTP HTTPS 协议.

数据包:  各种协议的首部 + 元素数据.

发送数据包:  应用程序 → TCP → IP → 网络接口
发送邮件的那一刻 建立TCP连接. 
TCP: 负责建立连接. 发送数据. 断开连接. . 为了实现TCP的功能需要加一个 TCP的首部.
源端口号 + 目标端口号 



路由表
网段/掩码 → 网关 (下一跳IP)  → 下一跳接口 →  跳数 















CCIE 证书

服务器集群. 负载均衡.  服务器虚拟化管理.

日志管理...

网站用户权限管理..













🔸 开机启动

	⦿ 推荐方式 Systemd
		好像不适合编译安装的命令
	
		常用命令
			# 立即启动一个服务              sudo systemctl start apache.service
			# 立即停止一个服务              sudo systemctl stop apache.service
			# 重启一个服务                  sudo systemctl restart apache.service
			# 杀死一个服务的所有子进程      sudo systemctl kill apache.service
			# 重新加载一个服务的配置文件    sudo systemctl reload apache.service
			# 重载所有修改过的配置文件      sudo systemctl daemon-reload
			# 显示某个 Unit 的所有底层参数  systemctl show httpd.service

	    systemctl enable zabbix-agent
	    systemctl disable zabbix-agent

　　在开机时启用一个服务：systemctl enable postfix.service
　　在开机时禁用一个服务：systemctl disable postfix.service
　　查看服务是否开机启动：systemctl is-enabled postfix.service;echo $?
　　查看已启动的服务列表：systemctl list-unit-files|grep enabled






	⦿ 方法2: rc.local

			⦿ 新建脚本  vi /home/boot.sh
				#!/bin/bash
				/usr/local/zabbix-server/sbin/zabbix_server

			⦿ 脚本权限	chmod +x /home/boot.sh

			⦿ rc.local 设置
					chmod 755 /etc/rc.d/rc.local

				vi /etc/rc.d/rc.local 添加  
					/bin/bash /home/boot.sh




		在工作中有脚本自启动的要求，而且自启动过程中，脚本需要指定为普通用户执行（非root权限）

		❗️❗️ 在/etc/rc.d/rc.local里面增加的脚本和指令总是不能自动加载和启动，机器启动后手动执行脚本又能成功，晕❗️❗️
		❗️❗️ 在/etc/rc.d/rc.local里面增加的脚本和指令总是不能自动加载和启动，机器启动后手动执行脚本又能成功，晕❗️❗️

		解决方式如下，/etc/rc.d/rc.local文件的文件头是#!/bin/sh ，我们把这修改成#!/bin/sh   -x，
		这样系统启动后就会把/etc/rc.d/rc.local里面的指令或脚本不能执行的日志写入/var/log/messages ,
		我们查看messages文件内容就知道具体的问题出在哪里了

			可能是执行那个脚本时，缺乏某些环境变量导致程序或动态库无法被找到。

				比如 “ip -6 addr add 2001::1 dev wlan0” 这一条，操作系统在执行rc.local的时候还看不懂。
				正确的应该是“/bin/ip -6 addr add 2001::1 dev wlan0”。
				原因应该是，执行它的时候，还没初始化$PATH变量。这样就可以解释为什么你之后可以手动启动而不出问题，因为这个时候你的$PATH变量已经初始化好了。


		那么就自己动手丰衣足食。把你的脚本单独存进一个文件例如叫/home/boot.sh 。
			在rc.loacl 里这样写一行/bin/bash  /home/boot.sh  1>> /etc/mylog    2>&1
			开机启动脚本要放到 home 目录下. 如果你放到 root 目录下. rc.local没权限看root目录的
