## 基础正则式


grep 最简单就是用固定字符串.

grep 有主要参数:
-i：模式匹配时忽略大小写
-V：显示不匹配的行
-l：列出匹配模式的文件名称,而不是打印匹配的行
-n：列出检索目标所在的行号
-c：统计匹配的行总数,不显示航信息






**正则式组成:  一般字符+特殊字符**

正则式有两种: 基本正则式表达 和 扩展正则式表达.



'' 先来看一些简单的匹配返利
'' tolstoy：匹配一行上任意位置的 7 个字母：tolstoy
'' ^tolstoy： 7 个字母 tolstoy，出现在一行的开头
'' tolstoy$：出现在一行的结尾
'' ^tolstoy$：正好包含这 7 个字母的一行，没有其他的任何字符。
'' [tT]olstoy： 在一行的任意位居中，含有 Tolstoy 或者 tolstoy
'' tol.toy：在一行的任意位居中，含有 tol 这三个字母，加上一个特殊字符，在接着 toy 这三个字母
'' tol.*toy：在一行的任意位居中，含有 tol 这三个字母，加上任意的 0 或者多个字符，再继续 toy 这三个字母（例如：toltoy，tolstoy，tolWHOtoy 都是满足要求的）。
'' 
'' shell 中的通配符：
'' *： 代表 0 个或者多个任意字符
'' ?： 代表一定有一个的任意字符
'' []： 代表一定有一个在括号内的字符（非任意字符）。例如[abcd]代表一定有一个字符，可能是 abcd 这四个选项的任意一个。
'' [-]：若邮件韩在括号内时，代表在编码顺序内的所有自负。例如：[0-9]代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的。
'' [^]： 若括号内的第一个字符为指数字符(^)，那表示反向选择，例如：[^abc]代表一定有一个字符，只要是非 abc 的其他字符就可以。
'' 
'' shell中的特殊字符：
'' #：注释字符
'' \：将特殊字符或者通配符还原成一般字符
'' |：管道符，分割两个管线命令的界定
'' ;：连续命令下达分隔符
'' ~：用户的家目录
'' $：放在变量前面，正确使用变量
'' &：工作控制，将命令编程背景下工作
'' !：非(!)的意思，逻辑运算符
'' >,>>：输出重定向，分别是覆盖和追加
'' <,<<：输入重定向
'' ‘’：单引号，不具有变量置换的功能
'' “”：双引号，具有变量置换的功能
'' ()：在中间的为子 shell 的起始与结束
'' {]：在中间为命令块的组合
'' 
'' shell 中正则表达式的控制字符
'' ^：匹配行首位置
'' $：匹配行尾位置
'' .：匹配任意祖父
'' *：对*之前的匹配整体或字符匹配任意次（包括 0 次）
'' \?：对\?之前的匹配整体或字符匹配 0 次或 1 次
'' \{n\}: 对 \ { 之前的匹配整体或字符匹配 n 次
'' \{m,\}: 对 \ { 之前的匹配整体或字符匹配至少 m 次
'' \{m,n}: 对 \ { 之前的匹配整体或字符匹配 m 到 n 次
'' [abcdef]: 对单字符而言匹配[]中的字符
'' [a-z]： 对单字符而言，匹配任意一个小写字母
'' [^a-z]：不匹配括号中的内容
















正则表达式语法


##### 正则表达式:

'' ^ 行首定位符 --------------- ^my ------ 所有 my 开头的行
'' $ 行尾定位符 --------------- my$ ------ 所有 my 结尾的行
'' . 匹配换行符以外的单个字符  -- m..y ----- 含字母m+任意两个字符+y 的行
'' * 匹配 0或多个前导字符  ----- my\* ----- 含字母m,后面跟0个或多个 y字母 的行.
'' [] ----------------------- [Mm]y ---- 含 My 或者 my 的行.
'' [^] ---------------------- [^Mm]y --- 含 y 但前面不是 M/m 的行.
'' \< 词首定位  -------------- \<my ----- 含 my 开头的单词的行
'' \> 词尾定位  -------------- \>my ----- 含 my 结尾的单词的行
'' x\{m\} 重复字符 x       m 次  /0\{5\} 匹配包含5个0 的行
'' x\{m,\} 重复字符 x 至少 m 次  /0\{5\} 匹配包含至少5个0 的行
'' x\{m,n\} 重复字符 x m-n 次  /0\{5,10\} 匹配包含 5-10 个0 的行
'' 
'' 
'' a\ 当前行下面 插入文本
'' i\ 当前行上面 插入文本
'' c\ 用符号后面的文本 替换当前行内容.
'' d 删除行
'' p 打印模板块的行
'' n 读取下一行
'' s 替换指定字符.
'' r file 从文件中读取行
'' w file 写 并追加模板块到文件末尾
'' = 打印当前行号
'' 
'' 
'' 
'' 替换标记
'' q 全局替换.
'' p 打印行
'' w 写入文件
 




⦿ 次数
	`*`  某个字符出现了0次或多次. 作用与左邻字符.
  `aA*c` 代表A这个字符 可能出现0个或多个 如: ac, aAc, aAAc, aAAAc 都符合

⦿ 个数
	`\{...\}` 指定符合的个数
	`\{3,5\}`表示前面的字符有 3-5个.
	`[a-z]\{3,5\}` 代表 小写字母组成的字符串, 长度是3-5

`\(...\)` 把比对符合的字符串 暂时保存起来.
`H\(...\)y` 表示要保存 H和y 之间的3个字符
如果要提取保存的字符串. 可以用位置参数: `\1` 表示第一个保存的字符串. `\2`代表第二个

- `\<` 词首:  `\<abc` 以abc为首的词
- `\>` 词尾:  `\>abc` 以abc结尾的词
- `i`  上一行插入 insert
- `a`  后一行附加 append 


*字符串: 编程时涉及最多的一种数据结构.对字符串操作的需求几乎无处不在*

比如判断一个字符串是否是合法的 Email 地址.

*正则表达式 是一种用来匹配字符串的强有力的武器.*

> 所以(J|j)ava(S|s)cript可以匹配'JavaScript'、'Javascript'、'javaScript'或者'javascript'。


`'00\d'可以匹配'007'，但无法匹配'00A'；`
`'\d\d\d'可以匹配'010'；`
`'\w\w'可以匹配'js'；`
`'js.'可以匹配'jsp'、'jss'、'js!'等等。`

`[0-9a-zA-Z\_]`  可以匹配一个数字、字母或者下划线； 
`[0-9a-zA-Z\_]+` 可以匹配至少由一个数字、字母或者下划线组成的字符串，比如'a100'，`0_Z`，'js2015'等等； 
`[a-zA-Z\_\$][0-9a-zA-Z\_\$]*`可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名； 
`[a-zA-Z\_\$][0-9a-zA-Z\_\$]{0, 19}` 更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。 
`js`   也可以匹配'jsp'，但是加上
`^js$` 就变成了整行匹配，就只能匹配'js'了。

##### 例子:
`\d{3}\s+\d{3,8}`

- `\d{3}` 表示匹配3个数字开头，例如'010'；
- `\s+`   表示至少有一个空格，
- `\d{3,8}`表示3-8个数字，例如'1234567'。  

综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。


##### 匹配'010-12345'
于'-'是特殊字符，在正则表达式中，要用'\'转义，
`\d{3}\-\d{3,8}`


##### 匹配'010 - 12345'

*JS 创建 正则表达式*
1. 直接写 表达式
2. 通过 new RegExp('表达式') 创建正则式对象

~~ ~~~
~~ var rel = /ABC\-001/;
~~ var rel2 = new RegExp('ABC\\-001');
~~ // 第二种 需要两个\\ 是由于 字符串转义的问题. 实际是一个\.
~~ 
~~ 
~~ *RegExp对象的 test()方法  用于测试给定的字符串是否符合条件。*
~~ ~~~
var re = /^\d{3}\-\d{3,8}$/;
console.log(re.test('010-12345'));   → true console.log(re.test('010-1234x'));   → false 


*切分字符串.*

`'a b   c'.split(' '); // ['a', 'b', '', '', 'c']` `'a b   c'.split(/\s+/); // ['a', 'b', 'c']`
我们需要的是去空格. 第一种就无法识别连续的多个空格..


`'a,b, c  d'.split(/[\s\,]+/);         // ['a', 'b', 'c', 'd']`
`'a,b;; c  d'.split(/[\s\,\;]+/);      // ['a', 'b', 'c', 'd']`

*如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。*


*分组: () + exec * 
除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。


~~ ~~~
~~ var re = /^(\d{3})-(\d{3,8})$/;
~~ re.exec('010-12345'); // ['010-12345', '010', '12345']
~~ re.exec('010 12345'); // null
~~ 
~~ 如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来。
~~ 
~~ - exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。
~~ - exec()方法在匹配失败时返回null。
~~ 
~~ 
~~ *识别合法的时间*
~~ `var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;`
~~ `re.exec('19:05:30'); // ['19:05:30', '19', '05', '30']`
~~ 时间提取. 小时不超过24.. 分钟不超60..
~~ 
~~ 
~~ 
~~ 
~~ *贪婪匹配(default)*
~~ 匹配尽可能多的字符.
~~ `var re = /^(\d+)(0*)$/;`
~~ `re.exec('102300'); // ['102300', '102300', '']`
~~ `由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。`
~~ 
~~ *加个 ?(0或1个字符) 就可以让 `\d+` 采用非贪婪匹配：*
~~ `var re = /^(\d+?)(0*)$/;`
~~ `re.exec('102300'); // ['102300', '1023', '00']`
~~ 
~~ 
~~ 
~~ 
~~ 
~~ ##### 全局搜索
~~ 
~~ JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配：
~~ 
~~ `var r1 = /test/g;`
~~ 
~~ ~~~
var s = 'JavaScript, VBScript, JScript and ECMAScript';
var re=/\[a-zA-Z]+Script/g;

// 使用全局匹配:
re.exec(s); // \['JavaScript']
re.lastIndex; // 10

re.exec(s); // \['VBScript']
re.lastIndex; // 20

re.exec(s); // \['JScript']
re.lastIndex; // 29

re.exec(s); // \['ECMAScript']
re.lastIndex; // 44

re.exec(s); // null，直到结束仍没有匹配到



*正则式表达*

`/and/gi`

// 是开始和 结尾.
and 是要查找的内容.
g 是全局查找
i 是忽略大小写


`/\d/g`  →  `\d` 是查找数字. 0-9 .

`/\d+/g` → 加号. 可以查找出多个结果.


`\n  newline`
`\t  tab`
`\f form feed`
`" " space`
`\s 也是空格`

/查找空格:


大写 就是 反选的意思:
`\s 是匹配空白.`
`\S 是匹配空白之外的所有符号.`
可用于文章字数计数器



*匹配特定字符串：*
`只能输入长度为3的字符："^.{3}$"。`
`只能输入由26个英文字母组成的字符串："^[A-Za-z]+$"。`
`只能输入由26个大写英文字母组成的字符串："^[A-Z]+$"。`
`只能输入由26个小写英文字母组成的字符串："^[a-z]+$"。`
`只能输入由数字和26个英文字母组成的字符串："^[A-Za-z0-9]+$"。`
`只能输入由数字、26个英文字母或者下划线组成的字符串："^\w+$"。`



*单词拆成字母:*

`hello → ["h","e","l","l","o"]`
str = "helli"
str = str.split(''); 
`var str="How are you doing today?"`
`document.write(str.split(" ") + "<br />")  How,are,you,doing,today?`
`document.write(str.split("") + "<br />")   H,o,w, ,a,r,e, ,y,o,u, ,d,o,i,n,g, ,t,o,d,a,y,?`
`document.write(str.split(" ",3))           How,are,you`
`   `




## 常用正则式

'' 常用的正则表达式主要有以下几种：
'' 　　匹配中文字符的正则表达式： [\u4e00-\u9fa5]
'' 　　评注：匹配中文还真是个头疼的事，有了这个表达式就好办了哦
'' 　　获取日期正则表达式：\d{4}[年|\-|\.]\d{\1-\12}[月|\-|\.]\d{\1-\31}日?
'' 　　评注：可用来匹配大多数年月日信息。
'' 　　匹配双字节字符(包括汉字在内)：[^\x00-\xff]
'' 　　评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
'' 　　匹配空白行的正则表达式：\n\s*\r
'' 　　评注：可以用来删除空白行
'' 　　匹配HTML标记的正则表达式：<(\S*?)[^>]*>.*?</>|<.*? />
'' 　　评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力
'' 　　匹配首尾空白字符的正则表达式：^\s*|\s*$
'' 　　评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式
'' 　　匹配Email地址的正则表达式：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*
'' 　　评注：表单验证时很实用
'' 　　匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*
'' 　　评注：网上流传的版本功能很有限，上面这个基本可以满足需求
'' 　　匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
'' 　　评注：表单验证时很实用
'' 　　匹配国内电话号码：\d{4}-\d{7}|\d{3}-\d{8}
'' 　　评注：匹配形式如 0511 - 4405222 或 021 - 87888822
'' 　　匹配腾讯QQ号：[1-9][0-9]\{4,\}
'' 　　评注：腾讯QQ号从1000 0 开始
'' 　　匹配中国邮政编码：[1-9]\d{5}(?!\d)
'' 　　评注：中国邮政编码为6位数字
'' 　　匹配身份证：\d{17}[\d|X]|\d{15}
'' 　　评注：中国的身份证为15位或18位
'' 　　匹配ip地址：((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。
'' 　　评注：提取ip地址时有用
'' 　　匹配特定数字：
'' 　　^[1-9]\d*$　//匹配正整数
'' 　　^-[1-9]\d*$ //匹配负整数
'' 　　^-?[1-9]\d*$　//匹配整数
'' 　　^[1-9]\d*|0$　//匹配非负整数（正整数 + 0）
'' 　　^-[1-9]\d*|0$　//匹配非正整数（负整数 + 0）
'' 　　^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$　//匹配正浮点数
'' 　　^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$　//匹配负浮点数
'' 　　^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$　//匹配浮点数
'' 　　^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$　//匹配非负浮点数（正浮点数 + 0）
'' 　　^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$　//匹配非正浮点数（负浮点数 + 0）
'' 　　评注：处理大量数据时有用，具体应用时注意修正
'' 　　匹配特定字符串：
'' 　　^[A-Za-z]+$　//匹配由26个英文字母组成的字符串
'' 　　^[A-Z]+$　//匹配由26个英文字母的大写组成的字符串
'' 　　^[a-z]+$　//匹配由26个英文字母的小写组成的字符串
'' 　　^[A-Za-z0-9]+$　//匹配由数字和26个英文字母组成的字符串
'' 　　^\w+$　//匹配由数字、26个英文字母或者下划线组成的字符串
'' 　　评注：最基本也是最常用的一些表达式
'' 　　Function IsRegu(Regu,s)
'' 　　'正则表达式校验
'' 　　If Regu="" Then
'' 　　Exit Function
'' 　　End if
'' 　　Dim Re,Sre
'' 　　Set Re = New RegExp
'' 　　Re.Pattern = Regu
'' 　　Sre = Re.Test(s)
'' 　　If Sre = True Then
'' 　　IsRegu = True
'' 　　Else
'' 　　IsRegu = False
'' 　　End If
'' 　　End Function
'' 　　tmp=" "
'' 　　if (IsRegu("\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*",tmp )) =false then
'' 　　msgbox "E-mail地址不合法 ！"
'' 　　FieldCheck#N=false
'' 　　end if
'' 　　不同的语言（如PHP和JAVA）、相同语言的不同类库（如来自Sun的Java Regular Expression类库跟Apache Jakarta的正则表达式类库）间，用法会有所差别，在使用的时候，要注意这些差别。




###### Regular Expression

- 简写: Regex、Regexp / RE,源于 Unix中的工具软件（如sed和grep）.
- 作用: **描述/匹配 符合某个语法规则的字符串**

技巧:   ^ 要   /g 也要.
'' sed -i 's/^#.ms-dns 192.168.1.1/ms-dns 8.8.8.8/g' /etc/ppp/options

> 不同系统,语法不一样.有些命令 debian 能用 mac 就不能用.

Mac :    BSD sed Ubuntu : GNU sed

###### 比如:
- 直接修改文件内的 xujian → xx
Debian
'' sed -i 's/xujian/xx' xujian.md

Mac : 
> 备份文件参数 变成必选. 需要提供一个空字符串做为备份文件名。
'' sed -i '' 's/xujian/xx' xujian.md


- 删除配置文件里的 # 号:
	sed ‘s#//.\*\#\#’ xx.md

在尾行添加1个空格

'' sed ‘s/\[0-9]$/& /g’ file > flile.new.conf



 
 
###### sed stream editor

- 流编辑器,用程序的方式来编辑文本.sed基本上就是玩正则模式匹配.
\- 
- i 命令 来直接修改文件. 免去重新定向输出才能修改文件.

- 默认输出: 所有内容的

- -n 仅显示处理后的结果.
	
	显示 第3行                             | sed -n '3p' xujian.md
	显示 1-7行                             | sed -n '1,7p' xujian.md
	删除 空白行                             | sed '/^$/d' xujian.md
	删除 第2行                             | sed '2d' xujian.md
	删除 尾行                              | sed '$d' xujian.md
	删除 最后两行                           | sed 'N;$d' xujian.md
	删除 2-10行                            | sed '2,10d' xujian.md
	删除 2-尾行                            | sed '2,$d' xujian.md
	删除 含 name 行                        | sed 'name' xujian.md
	删除 My 开头 行                        | sed '/^My/d' xujian.md
	删除 含 name 行 到 含 phone 行 之间的行  | sed '/name,/phone/d' xujian.md
	删除 含 name 行 到 第10行   之间的行     | sed '/name,10d' xujian.md
	替换 IP 成 localhost                  | sed 's/^IP/localhost/' xujian.md
	添加 IP 后添加 localhost               | sed 's/^IP/&localhost/' xujian.md



如何使用sed删除倒数第一行和倒数的几行？

只做一遍扫描的话难免要用到循环，看看下面这个能不能用吧：

- 删除倒数两行：
	seq 10 1 |sed -n '1{N;};:a;N;P;D;t a'

- 删除倒数三行：
	seq 10 1 |sed -n '1{N;N;};:a;N;P;D;t a'

其他依次类推，增加N的数量就行。

- 删除倒数一行最简单：
	seq 10 1 |sed -n ':a;N;P;D;t a'

或者
'' seq 10 1 | sed '$d'
'' seq 10 1 | sed -n '$q;p'



替换 所有My开头的 成 You  g 是全局的意思.
'' sed 's/^My/You/g' xujian.md



取消默认输出模式 在1-20行中 找 My 结尾的单词 并换成 You      全局查找 并打印到屏幕
'' sed -n '1,20s/My$/You/gp'

- 多重编辑命令. e 参数
多重编辑  选删除1-10行  再 把所有 My 替换成 Your
'' sed -e '1,10d' -e 's/My/Your/g' xujian.md




###### r 命令
将一个文件中的内容 添加到 当前文件的 特定位置.

'' sed '/My/r xx.md' xujian.md
xujian.md 文件中找到 My 行 
该行后 添加 xx.md 内容  (如果 找到很多行 My 则每行下面都加新文件内容)


将匹配行输出到文件.
'' sed -n '/root/w xujian.md'


在 passwd 文件找 root 行 把 xx.md 文件加到 root 行后面.
'' sed '/root/r xx.md' /etc/passwd 
'' 
'' 
'' sed '/root/{n;d}' xujian.md  找到 root 行  删除root 行的下一行.
'' sed '/root/{N;d}' xujian.md  找到 root 行  删除root 行及下一行.




######  sed 脚本编写:

新建 sed.sh 文件:
'' s/root/xujian/p
'' s/bash/csh/p

从文件读取命令
'' sed -f sed.sh

直接运行脚本 
'' ./sed.sh/etc/passwd
'' 
'' #!/bib/sed -f  
'' s/root/yerik/p  
'' s/bash/csh/p  


删除文件每行第一个字符

'' sed -n 's/^.//gp' /etc/passwd
'' sed -nr 's/(.)(.\*)/\2/p' /etc/passwd


删除文件每行的第二个字符。
'' sed -nr 's/(.)(.)(.\*)/\1\3/p' /etc/passwd
  
删除文件每行的最后一个字符。
'' sed -nr 's/.$//p' /etc/passwd
'' sed -nr 's/(.\*)(.)/\1/p' /etc/passwd
  
4，删除文件每行的倒数第二个字符。
'' sed -nr 's/(.\*)(.)(.)/\1\3/p' /etc/passwd
  
5，删除文件每行的第二个单词。
'' sed -nr 's/(\[^a-Z]*)(\[a-Z]+)(\[^a-Z]+)(\[a-Z]+)(.*)/\1\2\3\5/p' /etc/passwd
  
6，删除文件每行的倒数第二个单词。
'' sed -nr 's/(.*)(\[^a-Z]+)(\[a-Z]+)(\[^a-Z]+)(\[a-Z]+)(\[^a-Z]*)/\1\2\4\5\6/p' /etc/samba/smb.conf
  
7，删除文件每行的最后一个单词。
'' sed -nr 's/(.*)(\[^a-Z]+)(\[a-Z]+)(\[^a-Z]*)/\1\2\4/p' /etc/samba/smb.conf
  
8，交换每行的第一个字符和第二个字符。
'' sed -nr 's/(.)(.)(.\*)/\2\1\3/p' /etc/passwd
  
9，交换每行的第一个单词和第二个单词。
'' sed -nr 's/(\[^a-Z]*)(\[a-Z]+)(\[^a-Z]+)(\[a-Z]+)(.*)/\1\4\3\2\5/p' /etc/samba/smb.conf
  
10，交换每行的第一个单词和最后一个单词。
'' sed -nr 's/(\[^a-Z]*)(\[a-Z]+)(\[^a-Z]+)(\[a-Z]+)(.*)/\1\4\3\2\5/p' /etc/passwd
  
11，删除一个文件中所有的数字。
'' sed 's/\[0-9]\*//g' /etc/passwd
  
12，删除每行开头的所有空格。
'' sed -n 's/^\ *//p' /etc/samba/smb.conf
'' sed -nr 's/( *)(.\*)/\2/p' testp
  
13，用制表符替换文件中出现的所有空格。
'' sed -n 's/\ /\t/gp' pass
  
14，把所有大写字母用括号（）括起来。
'' sed -nr 's/(\[A-Z])/(&)/gp' testp
'' sed -n 's/\[A-Z]/(&)/gp' testp

15，打印每行3次。
'' sed 'p;p' pass
  
16，隔行删除。
'' sed -n '1\~2p' pass
  
17，把文件从第22行到第33行复制到第44行后面。
'' sed '1,21h;22h;23,33H;44G' pass
  
18，把文件从第22行到第33行移动到第44行后面。
'' sed '22{h;d};23,33{H;d};44G' pass
  
19，只显示每行的第一个单词。
'' sed -nr 's/(\[^a-Z]*)(\[a-Z]+)(\[^a-Z]+)(.*)/\2/p' /etc/passwd
  
20，打印每行的第一个单词和第三个单词。
'' sed -nr 's/(\[^a-Z]*)(\[a-Z]+)(\[^a-Z]+)(\[a-Z]+)(\[^a-Z]+)(\[a-Z]+)(.*)/\2--\4/p' /etc/passwd
  
21，将格式为    mm/yy/dd    的日期格式换成   mm；yy；dd
'' date +%m/%Y/%d |sed -n 's#/#;#gp'
  
22, 逆向输出
'' cat a.txt
'' ABC
'' DEF
'' XYZ
'' 输出样式变成
'' XYZ
'' DEF
'' ABC

- w 将所选行 写入文件

## grep:
Global Regular Expression Print  文本搜索工具.

例如：Handel、Händel和Haendel这三个字符串， 都可以由“H(a|ä|ae)ndel”这个模式来描述。 |竖直分隔符代表选择。例如: “gray|grey”可以匹配grey或gray。

### 数量限定符:
'' + ? * （不加数量限定则代表:仅出现一次）


|     符号  |    解释                                      |       备注          |
|:--------:|:-------------------------------------------- |:------------------:|
| +        | 代表前面的字符 至少出现一次。                       | 1次、或多次          |
| ?        | 代表前面的字符 最多出现一次。                     | 0次、或1次          |
| \*        | 代表前面的字符 可有可无可多次。                   | 0次、或1次、或多次    |
| goo+gle  | 匹配google、gooogle、goooogle等;               |                    |
| colou?r  | 匹配color或者colour;                           |                    |
| 0\*42     | 匹配42、042、0042、00042等。                    |                    |


### 匹配:
圆括号 限定操作符的范围     和优先度。

'' gr(a|e)y  ============== gray / grey
'' (grand)?father ========= father / grandfather


#### 贪婪模式: 尽可能少的匹配所搜索的字符串
#### 非贪婪模式: 尽可能多的匹配所搜索的字符串
对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。

'' \  接特殊字符
'' \n → 换行符.
'' \\ → \
'' \( → (


^ 匹配字符串的开始位置
$ 匹配字符串的结束位置
?  当紧跟在其他限制符 后面的话:开启 非贪婪模式

| | |
|:----------------------------------|:------------------------------------ |
| (?=)  正向肯定预查                   | (?!)  正向否定预查                    | | windows(?=95\|98\|2000\|xp)        | windows(?!95\|98\|2000\|xp)         |
| 能匹配 windows2000 里面的 windows    | 不能匹配 windows2000 里面的 windows   |
| 不能匹配 windows3  里面的 windows    | 能匹配 windows33  里面的 windows      |
|                                    |                                     |
| (?\<=)  反向肯定预查                  | (?\<!)  反向否定预查                  | | (?\<=95\|98\|NT\|2000)Windows       | (?\<=95|98|NT|2000)Windows          |
| 能匹配 2000windows 里面的 windows    | 不能匹配 2000windows 里面的 windows   |
| 不能匹配 3windows  里面的 windows    | 能匹配 33windows  里面的 windows      |




| 优先权 |             符号             |
|:-----:|:---------------------------:|
| 最高   |    \                          |
| 高    |  ( )、(?: )、(?= )、\[ ]      |
| 中    |  \*、+、?、{n}、{n,}、{m,n}    |
| 低    |  ^、$、中介字符               |
| 最低     |  |                          |



正则表达式:  使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。 
文本编辑器里:，通常被用来检索、替换那些符合某个模式的文本。



许多程序设计语言都支持利用正则表达式进行字符串操作。 例如，在Perl中就内建了一个功能强大的正则表达式引擎。



\*\* 功能 : \*\*  一个命令直接改文件内容: 不用 vi 查找 编辑 修改 保存退出.

## Perl
Perl兼容正则表达式，Perl Compatible Regular Expressions

编程语言.
最重要功能: 内部集成了 正则式表达功能 一级第三方代码库 CPAN

文件读取:  钻石符号: \<\>

$^I 

|  | 表达形式  | | |:----:|:----------:|:---:|
| 匹配：| m/~<regexp>~;/ （还可以简写为 /~<regexp>~;/ ，略去 m）
| 替换：| s/~<pattern>~;/~<replacement>~;/
| 转化：| tr/~<pattern>~;/~<replacemnt>~;/




















@: 1996-12-12-01-jQuery-正则式匹配
---
layout: post
title:  RegExp-jQuery-正则式匹配
tags: jQuery
categories: RegExp
---


 
'' ~
''  12.由26个英文字母组成的字符串                     /^[A-Za-z]+$/
''  13.由26个英文字母的大写组成的字符串           /^[A-Z]+$/
''  14.由26个英文字母的小写组成的字符串           /^[a-z]+$/
''  15.由数字和26个英文字母组成的字符串           /^[A-Za-z0-9]+$/
''  16.由数字、26个英文字母或者下划线组成的字符串             /^\w+$/
''  17.匹配所有单字节长度的字符组成的字符串                       /^[\x00-\xff]+$/
''  18.匹配所有双字节长度的字符组成的字符串                       /^[^\x00-\xff]+$/
''  19.字符串是否含有双字节字                                                 /[^\x00-\xff]+/
''  20.email地址             /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/
''  或者                     /w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*/
''  21.url地址                 /^[a-zA-z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\S*)?$/
''  或者                     /http://([w-]+.)+[w-]+(/[w- ./?%&=]*)?/
''  22.匹配中文字符的正则             /[u4e00-u9fa5]/
''  23.匹配双字节字符(包括汉字在内)             /[^x00-xff]/
''  应用：计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)
''  String.prototype.len=function(){
''  return this.replace([^x00-xff]/g,”aa”).length;
''  }
''  24.匹配空行的正则             /n[s| ]*r/
''  25.匹配HTML标记的正则             /<(.*)>.*</1>|<(.*) />/
''  26.匹配首尾空格的正则               /(^s*)|(s*$)/
''  应用：javascript中没有像vbscript那样的trim函数，我们就可以利用这个表达式来实现，如下：
''  String.prototype.trim = function(){
''  return this.replace(/(^s*)|(s*$)/g, “”);
''  }
''  27.匹配IP地址的正则             /(d+).(d+).(d+).(d+)/
''  应用：利用正则表达式匹配IP地址，并将IP地址转换成对应数值的Javascript程序：
''  function IP2V(ip){
''  re=/(d+).(d+).(d+).(d+)/g;
''  if(re.test(ip)){
''  return RegExp.$1*Math.pow(255,3))+
''  RegExp.$2*Math.pow(255,2))+
''  RegExp.$3*255+RegExp.$4*1;
''  }
''  else{
''  throw new Error(“Not a valid IP address!”);
''  }
''  }
''  其实直接用split函数来分解可能更简单，程序如下：
''  var ip=”10.100.20.168″;
''  ip=ip.split(“.”);
''  alert(“IP值是：”+(ip[0]*255*255*255+ip[1]*255*255+ip[2]*255+ip[3]*1));
''  28.去除字串中重复的字符的javascript程序
''  var s=”abacabefgeeii”;
''  var s1=s.replace(/(.).*1/g,”$1″);
''  var re=new RegExp(“["+s1+"]“,”g”);
''  var s2=s.replace(re,”");
''  alert(s1+s2);                     //结果为：abcefgi
''  /*使用后向引用取出包括重复的字符，再以重复的字符建立第二个表达式，取到不重复的字符，
''    两者串连。这个方法对于字符顺序有要求的字符串可能不适用。*/
''  29.用正则表达式从URL地址中提取文件名的javascript程序
''  s=”http://www.google.com/page1.htm“;
''  s=s.replace(/(.*/){0,}([^.]+).*/ig,”$2″);
''  alert(s);                             //结果为page1
''  30.限制表单文本框输入内容
''  只能输入中文：
''  onkeyup=”value=value.replace(/[^u4E00-u9FA5]/g,”)”
''  onbeforepaste=”clipboardData.setData(‘text’,
''  clipboardData.getData(‘text’).replace(/[^u4E00-u9FA5]/g,”))”
''  只能输入全角字符：
''  onkeyup=”value=value.replace(/[^uFF00-uFFFF]/g,”)”
''  onbeforepaste=”clipboardData.setData(‘text’,
''  clipboardData.getData(‘text’).replace(/[^uFF00-uFFFF]/g,”))”
''  只能输入数字：
''  onkeyup=”value=value.replace(/[^d]/g,”)”
''  onbeforepaste=”clipboardData.setData(‘text’,
''  clipboardData.getData(‘text’).replace(/[^d]/g,”))”
''  只能输入数字和英文：
''  onkeyup=”value=value.replace(/[W]/g,”)”
''  onbeforepaste=”clipboardData.setData(‘text’,
''  clipboardData.getData(‘text’).replace(/[^d]/g,”))”
''  31.验证文件名由字母，数字，下滑线组成                 /^((\w+)(\.{1})(\w+))$/
''  32.匹配日期(1900-1999)
''  /^19\d{2}-((0[1-9])|(1[0-2]))-((0[1-9])|([1-2][0-9])|(3([0|1])))$/
''  33.匹配日期(2000-2999)
''  /^20\d{2}-((0[1-9])|(1[0-2]))-((0[1-9])|([1-2][0-9])|(3([0|1])))$/
''  34.匹配日期时间
''  /^(1|2\d{3}-((0[1-9])|(1[0-2]))-((0[1-9])|([1-2][0-9])|(3([0|1]))))( (\d{2}):(\d{2}):(\d{2}))?$/
'' 网页验证的例子：
'' <SCRIPT language=”javascript”><!–
''  function validate(){
''  var frm = document.form1;
''  if ( frm.orgname.value==”" ){
''  alert(“机构名称必须填写,请输入!”);
''  frm.orgname.focus();
''  return false;
''  }
''  if ( frm.orgfunction.value==”" ){
''  alert(“机构职能必须填写,请输入!”);
''  frm.orgfunction.focus();
''  return false;
''  }
''  if ( frm.orgpostcode.value==”" ){…}
''  else{
''  var pattern=/^d…{6}$/;
''  if(pattern.test(frm.orgpostcode.value)){…}
''  else{
''  alert(“输入的邮政编码不是合法的格式!”);
''  frm.orgpostcode.focus();
''  return false;
''  }
''  }
''  if ( frm.orgphone.value==”" ){…}
''  else{
''  var str=frm.orgphone.value;
''  var reg=/(^[0-9]…{3,4}-[0-9]…{3,8}$)|(^[0-9]…{3,8}$)|(^([0-9]…{3,4})[0-9]…{3,8}$)|(^0…{0,1}13[0-9]…{9}$)/;
''  if (isNaN(str)){
''  if(reg.test(str)==false){
''  alert(“电话号码输入有误,请重新输入!”);
''  frm.orgphone.value=”";
''  frm.orgphone.focus();
''  return false;
''  }
''  }
''  else if(str.length<6){
''  alert(“电话输入有误,请重新输入!”);
''  frm.orgphone.focus();
''  return false;
''  }
''  }
''  if ( frm.orgfax.value==”" ){…}
''  else{
''  var str=frm.orgfax.value;
''  var reg=/(^[0-9]…{3,4}-[0-9]…{3,8}$)|(^[0-9]…{3,8}$)|(^([0-9]…{3,4})[0-9]…{3,8}$)|(^0…{0,1}13[0-9]…{9}$)/;
''  if (isNaN(str)){
''  if(reg.test(str)==false){
''  alert(“传真输入有误,请重新输入!”);
''  frm.orgfax.value=”";
''  frm.orgfax.focus();
''  return false;
''  }
''  }
''  else if(str.length<6){
''  alert(“传真输入有误,请重新输入!”);
''  frm.orgfax.focus();
''  return false;
''  }
''  }
''  if ( frm.orgemail.value==”" ){…}
''  else{
''  var pattern=/^w+((-w+)|(.w+))*@[A-Za-z0-9]+((.|-)[A-Za-z0-9]+)*.[A-Za-z0-9]+$/;
''  if(pattern.test(frm.orgemail.value)){…}
''  else{
''  alert(“输入的电子邮箱不是合法的格式!”);
''  frm.orgemail.focus();
''  return false;
''  }
''  }
''  if ( frm.orgurl.value==”" ){…}
''  else{
''  var pattern=new RegExp(“((^http)|(^https)|(^ftp))://(\w)+.(\w)+”);
''  if(pattern.test(frm.orgurl.value)){…}
''  else{
''  alert(“输入的URL不是合法的格式!”);
''  frm.orgurl.focus();
''  return false;
''  }
''  }
''  }
'' //–></SCRIPT>

