🔸 数据库种类

    • 关系型数据库代表:  MySQL、MariaDB、PostgreSQL、SQL Server、Oracle
    • 非关系数据库代表:  Redis、MongoDB、Memcached

    • 关系数据库. 数据在硬盘中.性能慢.
    • 非关系数据库. 数据在内存中.然后再写入硬盘.性能极快



🔸 2017.6 国内数据库排行榜

    1.  MySQL 
    2.  Oracle 
    3.  Microsoft SQL Server
    4.  Redis	
    5.  SparkSQL	
    6.  MongoDB	
    ...
    11.	SQLite
    12.	PostgreSQL
    ...
    17.	Memcached
    ...
    20.	MariaDB




🔸 PostgreSQL 简介 
    开源的关系型数据库 . 类似 mysql
    自从MySQL 被Oracle 收购后. PostgreSQL 逐渐成为开源关系型数据库的首选..
    PostgreSQL 的使用和 mysql 区别较大!  要重新学习..
    另外 PostgreSQL 也不是那么流行.
    虽然不少方面 比 MySQL 优秀. 如: PostgreSQL 自带全文搜索功能 (不用费劲再装一个 elasticsearch 咯):
    但是... 还不足以替代 mysql









🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸MySQL 发展🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸

🔸 简介

    MySQL 最知名的数据库.性能不错,高稳定,使用简单,功能强大.
    MySQL 绝对是排名靠前的王者.为早期的互联网发展作出了卓越的贡献.
    但是最近10几年,互联网发展十分迅速.随着访问量的上升,MySQL 开始出现了性能问题.
    优化数据库的结构 和 索引可以适当的增加 MySQL 性能. 但是这还不够.
    最初比较流行的解决方法是通过文件缓存来缓解数据库压力. 
    但是随着访问量的继续加大, 多台 web 服务器的缓存 不能共享.还是有性能问题.
    所以就有了 Memcached 这种技术.

🔸 Memcached

    Memcached 作为一个独立的分布式缓存服务器.
    为多个web服务器 提供了一个共享的高性能缓存服务器.
    而且你可以搭建 Memcached 缓存服务器机器来大大提高缓存性能.
    但是缓存只能缓解数据库读取方面的性能,MySQL 数据库的写入性能瓶颈还是存在.
    数据库读写操作集中在一台服务器上让服务器硬盘不堪重负! 于是有了 MySQL 主从复制和读写分离: 


🔸 主从复制 + 读写分离

    一台主服务器负责 MySQL 数据写入;一台从服务器负责 MySQL 数据读取.
    主从复制可以保证两台数据库的内容一致. 也就是主数据库写入的数据会同步到从数据库.
    读写锋利可以提高性能.一台服务器负责写入. 另外一台负责读取.    
    渐渐地主从复制 + 读写分离成为了网站标配. 随着访问量的继续加大.
    MySQL 主服务器的写压力开始出现瓶颈.毕竟只有一台服务器.硬盘写入也是有极限的.
    虽然 MySQL 后来推出了集群, 也就是你可以搭建多台主服务器 和多台从服务器.
    这样就可以把 主服务器的写入压力 分担给别的主服务器. 但是这个功能不好用!效果不理想
    相反的 MySQL 集群在高可靠方面非常不错! 
    但是这个不是我们面临的主要问题. 于是由出现了 MySQL 的分表分库这技术.注意这是两种技术.


🔸 分表分库

    分库: 就是把原本存储于一个库的数据分块存储到多个库上
    分表: 就是把原本存储于一个表的数据分块存储到多个表上

    ⦿ 为什么要分库分表？
        随着时间和业务的发展，库中的表会越来越多，表中的数据量也会越来越大，
        相应地，数据操作，增删改查的开销也会越来越大；

        当一张表的数据达到几千万时，你查询一次所花的时间会变多，
        就好比分别在1000万人 和1000人中找出某人,肯定后者容易找!
        甚至如果数据库设计过于复杂,可能会死机..
        分表的目的就在于此，减小数据库的负担，缩短查询时间。

        另外，一台服务器的资源（CPU、磁盘、内存、IO等）是有限的，
        最终数据库所能承载的数据量、数据处理能力都将遭遇瓶颈,。

    ⦿ 如何分库
        如果你的单机性能很低了，那可以尝试分库。
        在物理上分成多个服务器，不同的库在不同服务器上.
        用分库可以解决单台服务器性能不够，或者增删查改开销过高的问题

    ⦿ 如何分表
        某些表的数据量肯定会很大.比如预计肯定会超过5000万条.
        但是数据表设计的时候 最佳是 500万条. 这时候就要分表了.
        当某个表满了 就储存到另外的表中. 这时候查询数据会提高很多.
        查询比如查询第400万条数据 是在 分表一查询. 查询第800万条数据是在分表二查询.
        这样查询量级别就从 1/5000万 变成 1/500万 会快很多!!

    ⦿ 分库 分表区别
        分区和分表的测重点不同.
        分表重点是存取数据时，如何提高mysql并发能力上；
        而分区呢，如何突破磁盘的读写能力，从而达到提高mysql性能的目的。 


🔸 MySQL 瓶颈

    MySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，
    在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。
    比如1000万4KB大小的文本就接近40GB的大小，
    如果能把这些数据从MySQL省去，MySQL将变得非常的小。

    关系数据库很强大，但是它并不能很好的应付所有的应用场景。
    MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，
    表结构更改困难，正是当前使用MySQL的开发人员面临的问题。
    幸好有了 NOSQL 




🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸关系型数据库 ACID规则🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸

🔸 ACID 
    事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：

    ⦿ A (Atomicity) 原子性
        原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，
        事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。
        
        比如银行转账，从A账户转100元至B账户，
        分为两个步骤：1）从A账户取100元；2）存入100元至B账户。
        这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败钱会莫名其妙少了100元


    ⦿ C (Consistency) 一致性
        一致性也比较容易理解，也就是说数据库要一直处于一致的状态，
        事务的运行不会改变数据库原本的一致性约束。

        例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，
        使得事务结束后依然满足a+b=10，否则事务失败。


    ⦿ I (Isolation) 独立性
        所谓的独立性是指并发的事务之间不会互相影响，
        如果一个事务要访问的数据正在被另外一个事务修改，
        只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。

        比如现有有个交易是从A账户转100元至B账户，
        在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。

    ⦿ D (Durability) 持久性
        持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。




🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸CAP定理（CAP theorem🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸

在计算机科学中, CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer's theorem）, 
它指出对于一个分布式计算系统来说，不可能同时满足以下三点:
    • 一致性(Consistency) (所有节点在同一时间具有相同的数据)
    • 可用性(Availability) (保证每个请求不管成功或者失败都有响应)
    • 分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)

CAP理论的核心是：
    一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，
    最多只能同时较好的满足两个。

因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：
    • CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。
    • CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。
    • AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些



🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸NoSQL 发展🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸

🔸 简介 

    NoSql，全称是 Not Only Sql,字面意思是"不仅仅是SQL".其实指的是非关系型的数据库。
    NoSQL 是新一代的数据库! 主要解决几个要点：非关系型的、分布式的、开源的、水平可扩展的。

    NoSQL用于超大规模数据的存储,例如谷歌或Facebook等等





🔸 RDBMS vs NoSQL 区别

    关系型数据库设计之初是为了给国防、金融、政府及企业管理使用，
    对数据一致性要求极高，再加上当年存储成本高昂，业界努力的方向也是确保事务安全和减少数据冗余
    实体-关系模型提供了简单易学、健壮可靠，相对通用的软件数据建模方法，
    自然成为各种数据库软件的基础模型。


    非关系型数据库早就存在，但是因为缺乏必要的数据一致性保障而未能流行。
    直到 SNS 时代，社交网络应用对数据的一致性要求相对较低，
    对数据处理的实时性要求和大并发处理能力方面的要求非常高。
    通过放弃一致性检查和事务机制，非关系型数据库一般比关系型数据库拥有更好的性能，
    而且也不局限于实体-关系模型，能有更灵活的数据模型和操作方式供开发人员使用。 


    ⦿ 通俗解释
        把数据库想象成一个箱子!

        你往 SQL 型箱子放东西前必须用盒子装起来（盒子即是表），
        而且规定了一个盒子里只能放规格一致的东西（表中的记录都拥有相同的字段）。
        就像身份证信息库. 一个省一个表. 每个表都必须有身份证号这个字段(主键)


        你往 NoSQL 型箱子放东西时就没那么多限制了，
        只管放就行了，怕太乱就也用盒子装起来（盒子即是集合），
        但没有规格一致的限制（集合中的记录可以有不同的字段）。


    ⦿ 正规解释
        简单来说区别在于数据库软件是否负责维护数据间的关系。 

        关系型数据库是依照实体-关系模型建立起来的，它包括两个部分：
            一是数据库部分，负责数据的保存和索引，让你完成增删改查操作；
            另一个是关系部分，利用数据表把数据按行的形式组织起来，
            检查每个字段的数据类型、长度甚至取值范围，利用外键约束数据表之间的关系，


        非关系型数据库全部或者部分放弃了实体-关系模型，
        它们只负责保存数据，没有表，也不约束表间关系，关系的部分交由开发人员自己来完成。
            • 比如 MongoDB 用 JSON 序列化的方式保存数据，
                虽然也有表的概念，但是结构可以随时扩展调整，而无需更新既有数据。
            • 比如 LevelDB 是一个 Key-Value 数据库，重视写入性能而非读取性能。 
            • Redis 提供了 Key-Value 、 List 、 Set 、 Sorted Set 等多种数据结构模型。 
            • Cassandra 则使用面向列的数据模型。 




🔸 Why NoSQL

    NoSQL 现在是极其热门的新领域. 因为解决了很多关系型数据库难以解决的问题.
    而且随着时代的发展. 很多关系型数据库的特性也变得不那么重要了.
    也就加速了转用非关系型数据库的比例.
    
    下面三个问题在关系型数据库中往往难以解决.

    ⦿ 1.) 高并发读写需求
        现在的网站几乎都要使用 用户的个性化信息来实时生成动态页面! 因此数据库的并发负载特别高.
        往往每秒会有 上万次的读写请求.硬盘本来就是读取速度比写入速度快很多的.
        关系型数据库勉强能承受上万次的查询.但是硬盘的IO绝对无法承受上万次的写入.
        或许你会觉得这个是硬件问题, 和是否是关系型数据库没什么关系..

    ⦿ 2.) 海量数据的高校存储和访问需求
        比如 Fackbook 这样的社交网站. 几天就会就产生高达几亿条用户动态. 
        对关系型数据库来说,要在一张几亿条记录的表里面进行SQL查询,效率是极其低下,不可忍受的.
        再比如腾讯的用户登录系统, 数以亿计的帐号. 关系型数据库也是很难应付的.


    ⦿ 3.) 高可扩展性 高可用 需求
        web 架构中. 数据库是最难进行横向扩展的.
        对数据库的升级和扩展往往需要停机后才能进行,数据库的迁移就更加麻烦了. 
        对于 7*24 不间断的服务来说, 如果数据库不能便捷的扩展.这是不能接受的.


    下面几个关系型数据库的特性对很多网站来说是不需要的.

    ⦿ 1.) 数据库事物一致性需求.
        有些网站并不要求很严格的数据库事物, 对读写一致性的要求很低.
        因此数据库的事务管理成了数据库高负载的一个沉重的负担.

    ⦿ 2.) 数据库的写实时性 和 读实时性
        对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的.
        但是对于很多web应用来说，并不要求这么高的实时性，
        比如说我在qq里发一条动态，过几秒乃至十几秒之后，我的好友才看到这条动态是完全可以接受的.

    ⦿ 3.) 对复杂的SQL查询，特别是多表关联查询的需求 
        任何大数据量的web系统，都非常忌讳多个大表的关联查询，
        以及复杂的数据分析类型的复杂SQL报表查询，
        社交网站，从产品设计的时候就直接避免了这种情况的产生! 也就不需要多表关联查询的功能了.
        往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了


    所以 关系型数据库在这些应用场景就显得不那么合适了. 
    也就有了NoSQL 非关系型数据库的应运而生.
    近几年出现了各种各样的非关系型数据库.
    特别是键值数据库(Key-Value Store DB)风起云涌，多得让人眼花缭乱.
    现在起码有10+个 开源的 非关系数据库.例如: Redis、MongoDB 等等
    各种非关系型数据库都有特定的应用场景. 不能说Redis好. MongoDB不好!



🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸NoSQL 种类🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸🔸

🔸 满足极高读写性能需求的Kye-Value数据库：Redis

    Redis本质上是一个Key-Value类型的内存数据库，很像memcached.
    整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据写入到硬盘上进行保存。
    因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作.

    Redis的出色之处不仅仅是性能，
    Redis最大的魅力是支持保存List链表和Set集合的数据结构，而且还支持对List进行各种操作，
    例如从List两端push和pop数据，取List区间，排序等等，对Set支持各种集合的并集交集操作，
    此外单个value的最大限制是1GB，不像memcached只能保存1MB的数据，可以实现很多功能，
    另外Redis也可以对存入的Key-Value设置expire时间，
    因此也可以被当作一个功能加强版的memcached来用。 

    Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，
    并且它没有原生的可扩展机制，不具有scale（可扩展）能力，要依赖客户端来实现分布式读写，
    因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。
    目前使用Redis的网站有github...




🔸 满足海量存储需求和访问的面向文档的数据库：MongoDB

    面向文档的非关系数据库主要解决的问题不是高性能的并发读写，
    而是保证海量数据存储的同时，具有良好的查询性能。

    MongoDB是一个介于关系数据库和非关系数据库之间的产品，
    是非关系数据库当中功能最丰富，最像关系数据库的。
    他支持的数据结构非常松散，是类似json的bjson格式，因此可以存储比较复杂的数据类型。

    Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 

    Mongo主要解决的是海量数据的访问效率问题，
    当数据量达到50GB以上的时候，Mongo的数据库访问速度是MySQL的10倍以上。

    由于Mongo可以支持复杂的数据结构，而且带有强大的数据查询功能，因此非常受到欢迎，
    很多项目都考虑用MongoDB来替代MySQL来实现不是特别复杂的Web应用
    由于数据量实在太大，所以迁移到了Mongo上面，数据查询的速度得到了非常显著的提升。 



🔸 满足高可扩展性和可用性的面向分布式计算的数据库：Cassandra   

    很少用到.精力有限.不深入了.


















