🔸 Google 三大论文 

    Google的三篇论文影响了很多很多人，也影响了很多很多系统。
    这三篇论文一直是分布式领域传阅的经典。
    论文PDF中文版本下载:  http://cailin.iteye.com/blog/2299645

    根据MapReduce，于是我们有了Hadoop；
    根据GFS，于是我们有了HDFS；
    根据BigTable，于是我们有了HBase。

    而在这三篇论文里都提及Google的一个lock service---Chubby，哦，于是我们有了Zookeeper。



🔸 Hadoop、HDFS、HBase、Hive 简介 

    • Hadoop: 一种分析和处理大数据的软件平台

        把一个任务,分割成许多小的任务. 让集群上的节点服务器去执行这些小的任务.极大的增强运算能力.
        要完成这个看似简单的功能需要很多的额外工作.


    • HDFS:   分布式文件系统. 专门处理超大数据的文件! 常用于集群,为Hadoop提供文件上的支持!  


    • Hbase:  Hadoop 的数据库. Hadoop database 的缩写, NoSQL的一种,
            主要用于海量数据(上百亿)的随机实时查询, 如日志明细,交易清单.


    • Hive:   Hadoop 的数据仓库.
            主要让开发人员能够用SQL语法 来处理 HDFS上的结构化数据. 
            适用于离线的批量数据运算.


    ⦿ 在大数据架构中，Hive和HBase是协作关系，数据流一般如下图：

      1. 通过ETL工具将数据源抽取到HDFS存储；
      2. 通过Hive清洗、处理和计算原始数据；
      3. HIve清洗处理后的结果，如果是面向海量数据随机查询场景的可存入Hbase
      4. 数据应用从HBase查询数据；




🔸 NameNode (HDFS)

    HDFS 集群是以 Master-Slave 模式运行的.
    一个主节点: Namenode 
    多个从节点: Datanode

    ⦿ NameNode 简介

        电脑的文件其实是好几部分组成的!  
        文件名、文件权限等等 这类的元属性存在一个地方,文件真实内容存在另一个地方! 
        元信息里面会有 文件真实内容在硬盘上的存储位置.

        这也是为什么文件搜索速度会这么快, 整个硬盘其实文件名这样的元数据都在一个地方的.
        按文件名找文件的话只要搜索元数据这一小块内容,就能确实是否有这个文件.还有这个文件真实内容的位置.
        而不是说你要找某个文件夹.电脑会把整个硬盘从头到尾搜索一遍!!!

        这也是为什么文件能恢复的原因! 
        你在电脑桌面看到的文件只是一个文件名而已. 文件的真实内容其实和文件名是分开的.
        你删除了文件,只是删除了文件的元信息而已. 文件的真实内容其实还没有删除! 

        就好比身份证, 有了你的身份证就能知道你住哪里. 但是如果我烧了你的身份证,不代表你的人也被我烧了.

        Namenode 就是管理这些 文件元数据的, Namenode 记录着每个文件在硬盘中的位置信息，
        Datanode 就是管理这些 文件真实数据的.


    ⦿ NameNode 作用 
        没有 NameNode HDFS就不能工作! 
        如果 运行 NameNode 的服务器坏掉,那么集群中的所有文件将完全丢失!
        虽然能恢复一些数据,但是那个是非常非常麻烦的

        所以 Namenode 的容错机制非常重要!
        第一种方法是实时备份 Namenode 到别的电脑.
        第二种方法是加个 辅助的Namenode 也就是 secondary namenode. 哪天主服务器挂了就用辅助的服务器.
        但是辅助的Secondary namenode 和真正的 namenode 还是有区别的. 
        所以主服务器挂了的话,还是会丢失一小部分的数据.




🔸 HMaster (HBase)

    Hbase 是个分布式数据库. 也是主从结构的.
    主节点: HMaster. 
    从节点: HRegion

    这里的 HMaster 没有单点问题, 集群中可以有多个 HMaster的存在.



🔸 Zookeeper  开源的分布式应用程序协调服务

  　Zookeeper 分布式服务框架是 Apache Hadoop 的一个子项目，
      它主要是用来解决分布式应用中经常遇到的一些数据管理问题，
      如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等等。

    ZooKeeper 顾名思义 动物园管理员，他是拿来管大象(Hadoop) 、蜜蜂(Hive) 的管理员， 

    Zookeeper 从程序员的角度来讲可以理解为Hadoop的整体监控系统。

    如果 HDFS 文件系统的 Namenode 挂了, 虽然你有备份,但是备份只是备份. 
    你需要手动把 NameNode的备份服务器设为新的 NameNode 服务器后, HDFS 才能恢复正常
    用 Zookeeper 的话可以自动把备份系统转为主系统. 保证服务正常运行, 这是它最大的作用所在。

    就像 mysql 集群, 你需要在集群前加一个代理服务器来让用户访问.
    如果这个代理服务器挂了.你的整个集群也挂了.
    这时候你就需要搭建 一主两从的 代理服务器. 主的挂了 就让从的变成主的.
    Mysql 要实现这样的高可用 需要使用 HaProxy .
    同样的 Hadoop 里面的某些服务要实现高可用就要使用 Zookeeper.





🔸 Zookeeper 角色

    领导者: leader    负责进行投票的发起 和 决定. 
    更随者: Follower  参与选主的投票、接收客户端请求,向客户端返回结果.
    客户端: Client    发起请求


🔸 Zookeeper 架构
  主从结构:  一个Leader . 多个Follwer.  
  如果Leader 挂了, 会在毫秒级别内重新选举出一个新的 Leader.




🔸 Zookeeper 设计目的 

    其实就是管理, Hadoop里面各种主从服务的 主服务器的! 
    如果某个主挂了, 那么必须立刻把某个从 变成主.
    而且这个变化时间必须非常的短!

    Zookeeper 做了很多努力才能达到上面的要求.

    所有客户端都是连到 Zookeeper 上的! 
    所以Zookeeper 是一个集群, 有很多的从服务器.这样才能满足海量客户端的查询.
    ZooKeeper 服务器会告诉客户端, 对应服务的主节点IP是多少.


    ⦿ 最终一致性 

        客户端不管连到那个 zookeeper 服务器. 得到的都会是同一个结构.
        就算当时某个主坏了. 把从换成新主的过程中. 客户端联系不上主服务器,会自动等待,
        所有客户端得到的都将会是新主的IP.

    ⦿ 可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。

    ⦿ 实时性：

        Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。
        但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，
        如果需要最新数据，应该在读数据之前调用sync()接口。
        等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。


    ⦿ 原子性：更新只能成功或者失败，没有中间状态。

    ⦿ 顺序性：
        
        包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。





🔸 Zookeeper 工作原理

    Zookeeper 的核心是广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。

    Zab协议有两种模式，它们分别是恢复模式（选主）和广播 模式（同步）。
    当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，
    当领导者被选举出来，且大多数Server完成了和leader的状态同步以后， 恢复模式就结束了。
    状态同步保证了leader和Server具有相同的系统状态。
    为了保证事务的顺序一致性，zookeeper采用了递增的事务id号 （zxid）来标识事务。
    所有的提议（proposal）都在被提出的时候加上了zxid。
    实现中zxid是一个64位的数字，它高32位是epoch用 来标识leader关系是否改变，
    每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。


    每个Server在工作过程中有三种状态：

    LOOKING：当前Server不知道leader是谁，正在搜寻。
    LEADING：当前Server即为选举出来的leader。
    FOLLOWING：leader已经选举出来，当前Server与之同步。
