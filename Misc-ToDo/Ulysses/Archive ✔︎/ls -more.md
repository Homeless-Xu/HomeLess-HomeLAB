
## ls |more 


或者 手动安装 tree 命令    就能以树形结构看文件目录了.




用s///和正则表达式就可以完成



perl 正则式表达:看




sed:




这三种形式一般都和 = 或 ! 搭配使用（其中 "=" 表示相匹配，在整条语句中读作 does，"!" 表示不匹配，在整条语句中读作 doesn't），并在左侧有待处理的标量变量。如果没有该变量和 = ! 操作符，则默认为处理 $_ 变量中的内容。举例如下：


$str = "I love Perl";

$str = m/Perl/; # 表示如果在 $str 中发现 "Perl" 字符串，则返回 "1" 否则返回 "0"。

$str = s/Perl/BASH/; # 表示将变量 $str 中的 "Perl" 字符串替换为 "BASH"，如果发生此替换则返回 "1"，否则返回 "0"。

$str ! tr/A-Z/a-z/; # 表示将变量 $str 中的所有大写字母转化为小写字母，如果转化发生了则返回 "0"，否则返回 "1"。


另外还有：


foreach (@array) { s/a/b/; } # 此处每次循环将从 @array 数组中取出一个元素存放在 $_ 变量中，并对 $_ 进行替换处理。

while (\<FILE\>;) { print if (m/error/); } # 这一句稍微复杂一些，他将打印 FILE 文件中所有包含 error 字符串的行。


Perl 的正则表达式中如果出现 () ，则发生匹配或替换后 () 内的模式被 Perl 解释器自动依次赋给系统 $1, $2 ...... 请看下面的例子：


$string = "I love perl";

$string = s/(love)/<$1>;/; # 此时 $1 = "love"，并且该替换的结果是将 $string 变为 "I <love>; perl"

$string = "i love perl";

$string = s/(i)(.)(perl)/<$3>;$2<$1>;/; # 这里 $1 = "i"，$2 = " love "，$3 = "perl"，并且替换后 $string 变为 "<perl>; love <i>;"


替换操作 s/\<pattern\>;/\<replacement\>;/ 还可以在末尾加上 e 或 g 参数，他们的含义分别为：


s/\<pattern\>;/\<replacement\>;/g 表示把待处理字符串中所有符合 \<pattern\>; 的模式全部替换为 \<replacement\>; 字符串，而不是只替换第一个出现的模式。

s/\<pattern\>;/\<replacement\>;/e 表示将把 \<replacemnet\>; 部分当作一个运算符，这个参数用的不多。


比如下面的例子：


$string = "i:love:perl";

$string = s/://; #此时 $string="ilove:perl";

$string = "i:love:perl";

$string = s/://g; #此时 $string="iloveperl"; 

$string = tr// /; #此时 $string="i love perl"; 

$string = "www22cgi44";

$string = s/(\d+)/$12/e; # (/d+)代表 $string 中的一个或多个数字字符，将这些数字字符执行 2 的操作，因此最后 $string 变成了 "www44cgi88"。


下面给出一个完整的例子：


# !/usr/bin/perl


print"请输入一个字符串!\n";

$string = \<STDIN\>;; # \<STIDN\>;代表标准输入，会让使用者输入一字符串

chop($string); # 将$string最后一个换行的字符\n删除掉

if($string = /perl/){

　　print("输入的字符串中有 perl 这个字符串!\n";

}


如果输入的字符串含有 perl 这个字符串的话，就会显示后面的提示信息。


 


9.2 正则表达式中的常用模式

下面是正则表达式中的一些常用模式。


/pattern/  结果  

. 匹配除换行符以外的所有字符 

x? 匹配 0 次或一次 x 字符串 

x* 匹配 0 次或多次 x 字符串，但匹配可能的最少次数 

x+ 匹配 1 次或多次 x 字符串，但匹配可能的最少次数 

.* 匹配 0 次或一次的任何字符 

.+ 匹配 1 次或多次的任何字符 

{m} 匹配刚好是 m 个 的指定字符串 

{m,n} 匹配在 m个 以上 n个 以下 的指定字符串 

{m,} 匹配 m个 以上 的指定字符串 

[]() 匹配符合 []() 内的字符 

[^]() 匹配不符合 []() 内的字符 

[0-9]() 匹配所有数字字符 

[a-z]() 匹配所有小写字母字符 

[^0-9]() 匹配所有非数字字符 

[^a-z]() 匹配所有非小写字母字符 

^ 匹配字符开头的字符 

$ 匹配字符结尾的字符 

\d 匹配一个数字的字符，和 [0-9]() 语法一样 

\d+ 匹配多个数字字符串，和 [0-9]()+ 语法一样 

\D 非数字，其他同 \d 

\D+ 非数字，其他同 \d+ 

\w 英文字母或数字的字符串，和 [a-zA-Z0-9]() 语法一样 

\w+ 和 [a-zA-Z0-9]()+ 语法一样 

\W 非英文字母或数字的字符串，和 [^a-zA-Z0-9]() 语法一样 

\W+ 和 [^a-zA-Z0-9]()+ 语法一样 

\s 空格，和 [\n\t\r\f]() 语法一样 

\s+ 和 [\n\t\r\f]()+ 一样 

\S 非空格，和 [^\n\t\r\f]() 语法一样 

\S+ 和 [^\n\t\r\f]()+ 语法一样 

\b 匹配以英文字母,数字为边界的字符串 

\B 匹配不以英文字母,数值为边界的字符串 

a|b|c 匹配符合a字符 或是b字符 或是c字符 的字符串 

abc 匹配含有 abc 的字符串 

(pattern) () 这个符号会记住所找寻到的字符串，是一个很实用的语法。第一个 () 内所找到的字符串变成 $1 这个变量或是 \1 变量，第二个 () 内所找到的字符串变成 $2 这个变量或是 \2 变量，以此类推下去。  

/pattern/i i 这个参数表示忽略英文大小写，也就是在匹配字符串的时候，不考虑英文的大小写问题。 

\ 如果要在 pattern 模式中找寻一个特殊字符，如 "*"，则要在这个字符前加上 \ 符号，这样才会让特殊字符失效 

 


下面给出一些例子：    


范例 说明 

/perl/ 找到含有 perl 的字符串 

/^perl/ 找到开头是 perl 的字符串 

/perl$/ 找到结尾是 perl 的字符串 

/c|g|i/ 找到含有 c 或 g 或 i 的字符串 

/cg{2,4}i/ 找到 c 后面跟着 2个到 4个 g ，再跟着 i 的字符串 

/cg{2,}i/ 找到 c 后面跟着 2个以上 g ，再跟着 i 的字符串 

/cg{2}i/ 找到 c 后面跟着 2个 g，再跟着 i 的字符串 

/cg*i/ 找到 c 后面跟着 0个或多个 g ，再跟着 i 的字符串，如同/cg{0,1}i/ 

/cg+i/ 找到 c 后面跟着一个以上 g，再跟着 i 的字符串，如同/cg{1,}i/ 

/cg?i/ 找到 c 后面跟着 0个或是 1个 g ，再跟着 i 的字符串，如同/cg{0,1}i/ 

/c.i/ 找到 c 后面跟着一个任意字符，再跟着 i 的字符串 

/c..i/ 找到 c 后面跟着二个任意字符，再跟着 i 的字符串 

/[cgi]()/ 找到符合有这三个字符任意一个的字符串 

/[^cgi]()/ 找到没有这三个字符中任意一个的字符串 

/\d/ 找寻符合数字的字符，可以使用/\d+/来表示一个或是多个数字组成的字符串 

/\D/ 找寻符合不是数字的字符，可以使用/\D+/来表示一个或是更多个非数字组成的字符串 

/\*/ 找寻符合 * 这个字符，因为 * 在常规表达式中有它的特殊意思，所以要在这个特殊符号前加上 \ 符号，这样才会让这个特殊字符失效 

/abc/i 找寻符合 abc 的字符串而且不考虑这些字符串的大小写 


 


9.3 正则表达式的八大原则

　　如果在 Unix 中曾经使用过 sed、awk、grep 这些命令的话，相信对于 Perl 语言中的正则表达式(Regular Expression)不会感到陌生。Perl 语言由于有这个功能，所以对字符串的处理能力非常强。在Perl语言的程序中，经常可以看到正则表达式的运用，在 CGI 程序设计中也不例外。


　　正则表达式是初学 Perl 的难点所在，不过只要一旦掌握其语法，你就可以拥有几乎无限的模式匹配能力，而且 Perl 编程的大部分工作都是掌握常规表达式。下面给大家介绍几条正则表达式使用过程中的 8 大原则。 


　　正则表达式在对付数据的战斗中可形成庞大的联盟——这常常是一场战争。我们要记住下面八条原则：


· 原则1：正则表达式有三种不同形式(匹配(m/ /)，替换(s/ / /eg)和转换(tr/ / /))。


· 原则2：正则表达式仅对标量进行匹配( $scalar = m/a/; 可以工作; @array = m/a/ 将把@array作为标量对待，因此可能不会成功)。


· 原则3：正则表达式匹配一个给定模式的最早的可能匹配。缺省时，仅匹配或替换正则表达式一次( $a = 'string string2'; $a = s/string/ /; 导致 $a = 'string 2')。


· 原则4：正则表达式能够处理双引号所能处理的任意和全部字符( $a = m/$varb/ 在匹配前把varb扩展为变量；如果 $varb = 'a' $a = 'as'，$a = s/$varb/ /; 等价于 $a = s/a/ /; ，执行结果使 $a = " s" )。


· 原则5：正则表达式在求值过程中产生两种情况：结果状态和反向引用： $a= m/pattern/ 表示 $a 中是否有子串 pattern 出现，$a = s/(word1)(word2)/$2$1/ 则“调换”这两个单词。


· 原则6：正则表达式的核心能力在于通配符和多重匹配运算符以及它们如何操作。$a = m/\w+/ 匹配一个或多个单词字符；$a = m/\d/" 匹配零个或多个数字。


· 原则7：如果欲匹配不止一个字符集合，Perl使用 "|" 来增加灵活性。如果输入 m/(cat|dog)/ 则相当于“匹配字符串 cat 或者 dog。


· 原则8：Perl用 (?..) 语法给正则表达式提供扩展功能。（这一点请同学们课后看相关资料）


想要学习所有这些原则？我建议大家先从简单的开始，并且不断的尝试和实验。实际上如果学会了 $a = m/ERROR/ 是在 $a 中查找子串ERROR，那么你就已经比在 C 这样的低层语言中得到了更大的处理能力。




apt-get update是更新仓库数据
◦	upgrade不是更新系统？









Git 教程:
基本命令和操作

新建仓库: 先网站上新建  再 clone到本地



git clone + 仓库网址 : 已经有个 远程仓库.  克隆一个到本地电脑

git clone https://github.com/Xu-Jian/DSM.git
 
 
 
 二、 Git 常用命令

1) 远程仓库相关命令
检出仓库：        $ git clone git://github.com/jquery/jquery.git
查看远程仓库：$ git remote -v
添加远程仓库：$ git remote add [name]() [url]()
删除远程仓库：$ git remote rm [name]()
修改远程仓库：$ git remote set-url --push [name]() [newUrl]()
拉取远程仓库：$ git pull [remoteName]() [localBranchName]()
推送远程仓库：$ git push [remoteName]() [localBranchName]()

*如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：
$git push origin test:master         // 提交本地test分支作为远程的master分支
$git push origin test:test              // 提交本地test分支作为远程的test分支
 
 
 
 
 
 
 
 
 
 
 
 
 
 



 

PS :GIT的使用和SVN这类中心式的架构有很大不同。要把本地项目创建到GIT SERVER上，需要费点周折。

简单的说可以按照如下步骤：

1.先在本地创建项目，有个项目目录

2.然后在本地的这个项目目录中执行git --bare init进行初始化。

3.然后将需要提交的文件提交到本地

4.然后将项目目录COPY到服务器上，只COPY  .git 目录就行，其他工作目录不用COPY的。

5.在本地就可以推送到远程服务器上了。

还有一种方法：

如果本地初始化的时候使用的是git init，那么推送就会出现问题。

解决方法是将本地的目录全部COPY到服务器上。

然后再服务器对应目录下面执行：

git config --bool core.bare true
接着删除掉除.git目录之外的所有文件和目录即可。
这样本地就能顺利推送了。

当然直接使用

git clone --bare hello hello.git
这样直接导出裸库，然后将hello.git 这个目录直接上传到服务器上也可以。不过地址需要加上hello.git这个的目录。




# 设备:
- 群辉NAS:   IP : 192.168.1.7
- 路由器:    IP : 192.168.1.1 网件 6300  刷 dd-wrt.



## 群辉:
- 下载+启用+打开  radius server 这个套件

### 设置:
-   验证端口: 1812
-   选择验证用户所针对的来源  → 本地用户

### 客户端:
 新增  
- 名称: 随便填
- 秘钥: 大于8位  这里: 12345678
- 来源 IP:就是哪个路由器的 wifi 要开启 验证才能登录.
单一主机: 192.168.1.1 



## 路由器设置

- 不需要开启 radius 功能: 无线 → radius → 启用 →

- 只需要:无线 → 无线安全 → 安全模式: → wp2 enterprise
服务器地址 192.168.1.7
端口 1812
共享秘钥 12345678



## 手机
- 选择wifi  连接. 
- 输入 nas 中已经创建好的账号密码.
- 安装证书.


通过 nas 账号 来管理 wifi权限.

[1]():	https://www.synology.cn/zh-cn/knowledgebase/tutorials/592
[2]():	smb://xujian.myDS.me
[3]():	https://www.synology.cn/zh-cn/knowledgebase/faq/299





























